## 

# 比特位计数

## 题目描述

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例1:

> ```
> 输入: 2
> 输出: [0,1,1]
> ```

示例2:

> ```
> 输入: 5
> 输出: [0,1,1,2,1,2]
> ```

进阶:

- 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？


- 要求算法的空间复杂度为**O(n)**。

- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作

## 题目来源:

> ```
> 剑指offer(专项突击版) [剑指offer|| 003]前n个数字二进制中1的个数
> ```

[力扣 338.比特币计数]: https://leetcode-cn.com/problems/counting-bits/

## 题解

> 为了表述简洁，下文用「一比特数」表示二进制表示中的 1 的数目。

### 解法一 暴力枚举

> 这是我最先想到的方法,两个循环暴力枚举直接出结果，但是这种方法的时间复杂度和空间复杂度都很高.
>
> 定义一个数组，将0~n进行遍历，将循环中的i转换成二进制字符串，然后将二进制字符串分割成数组chars，再对chars进行遍历，如果chars[j]=‘1’,sum++;遍历完之后将sum添加到数组中.



```javascript
var countBits = function(n) {

    let sum = 0;
    let number = [];
    for(let i=0;i<=n;i++ ){
        let value = i.toString(2);
        let chars = value.split('');
        for(let j=0;j<chars.length;j++){
            if(chars[j] == '1')
                sum++;
        }
        number.push(sum);
        sum=0;
    }
    return number

 }
```

### 解法二  Brian Kernighan算法位运算

> 位运算&表示**同1为1**, 令**x&(x-1)**,该运算将x的二进制表示的最后一个1变成0，因此，对 *x* 重复该操作，直到x变成0,则操作次数即为x的「一比特数],例如：令x=10，二进制表示位1010,(x-1)=9.二进制表示为1001,10&9=1000. 1000比1010少了一个1
>
> 对于给定的 n，计算从 0 到 n 的每个整数的「一比特数」的时间都不会超过 )O(logn)，因此总时间复杂度为 O(nlogn)。

```javascript
var countBits = function(n) {
	   const  bits = new Array(n+1).fill(0)
    for(let i=0;i<=n;i++){
        let num = getNumOne(i);
        bits[i] = num;
    }
    return bits;
 }
var getNumOne = function (n){
    let x=0
    while(n>0){
        n&=(n-1);//n&(n-1) = (n-1)
        x++;
    }
    return x
}
```

**时间复杂度**:O(nlogn)。需要对从0到n的每个整数使用计算「一比特数」，对于每个整数计算							「一比特数」的时间都不会超过O(logn)。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法三 动态规划 位运算(最高有效位)

> 当计算 i 的「一比特数」时，如果存在 0 <=j<i，j 的「一比特数」已知，且 i 和 j 相比，i的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。
>
> 上述关系可以表示成: **bits[i]=bits[j]+1**
>
> 对于正整数x，如果可以知道最大的整数y,使得y<=x并且y是2的整数次幂，则y的二进制表示中只有最高位是1，其余都是0，此时称 *y* 为 *x* 的「最高有效位」。**令z=x-y,则bits[x]=bits[z]+bits[y]=bits[z]+1**
>
> 为了判断一个正整数是不是 2 的整数次幂，可以利用方法二中提到的按位与运算的性质,如果y是2的整数次幂,则y&(y-1)=0;由此可见没正整数y是2的正整数次幂，当且仅当y&(y-1)=0
>
> 如果i&(i-1)=0,则令hignBit=i,更新当前的最高有效位
>
> **bits[i]=bits[i-hignBit]+1**
>
> 

```javascript
   const  bits = new Array(n+1).fill(0);
    let hignNum=0;
    for(let i=1;i<=n;i++){
        if((i&(i-1))==0){
            hignNum = i;
        }
        bits[i] = bits[i-hignNum]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法四 动态规划 位运算(设置最低位)

> 定义正整数 x 的「**最低设置位**」为 *x* 的二进制表示中的最低的 1 所在位，例如，10的二进制表示是1010，其最低设置位是2，二进制表示为10
>
> 令y=x&(x-1),则y为将x的最低设置位从1变成0之后的数，显然0<=y<=x,bits[x]=bits[y]+1,
>
> 对于任意正整数x，都有bits[x]=bits[x&(x-1)]+1

```javascript
 const  bits = new Array(n+1).fill(0)
    for(let i=1;i<=n;i++){
        bits[i]=bits[(i&(i-1))]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法五 动态规划 位运算(最低有效位)

> 对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是[x/2],如果bits[x/2]已知，则可以得到bits[x]的值
>
> - 如果 x 是偶数，bits[x]=bits[x>>1]
>
> - 如果 x 是奇数，bits[x]=bits[x>>1]+1
>
> 判断x的奇偶可以通过x&1得到，如果为奇数，x&1=1，反之为0
>
> 则 bits[x]=**bits[x>>1]+(x&1)**



```javascript
    const bits = new Array(n+1).fill(0);
    for(let i = 1;i<=n;i++){
        bits[i] = bits[i>>1]+(i&1)
    }
    return  bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

# 二进制加法

## 1.题目描述

```
给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。
```

```
示例 1:
输入: a = "11", b = "10"
输出: "101"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。
```

## 2.题目来源

> 剑指offer(专项突击版) [剑指offer|| 002]二进制加法

[力扣官网](https://leetcode-cn.com/problems/add-binary/)

## 3.题解

**解答这道题的问题是两个数的加法运算是从低位到高位的,我们要将字符串从后往前遍历，最后求得的结果再翻转**

**另外我们还要考虑两个字符串长度不一样的情况，遍历时我们需要判断字符串是否遍历完成，这样才能获取正确结果**

下方代码中，**ans**表示**结果字符串**，**ca**表示进**位的值**，**sum**表示**当前遍历位的值**，**如果sum>=2,我们需要往后进一位，遍历到下一个值时，我们需要让sum加上遍历上一个值是所进的位数值**

```javascript
var addBinary = function(a, b) {
    let ans =''
    let ca = 0
    for(let i =a.length-1,j=b.length-1;i>=0||j>=0;i--,j--){
        let sum = ca
        sum += i>=0 ? parseInt(a[i]) : 0//如果a遍历完成了,sum不再加a[i]
        sum += j>=0 ? parseInt(b[j]) : 0//如果b遍历完成了,sum不再加b[i]
        ans += sum % 2 //将当前位的值加入到ans中，如果sum=2，则当前位为0
        ca = Math.floor(sum / 2)//向下取整sum/2,如果sum=2，则进位加1
    }
    ans += ca>0? 1 : ''//最后判断进位的值，如果ca>0，结果应该加进位1，否则不变
    return ans.split('').reverse().join('')//最后将字符串进行反转求得结果
};
```

# 移除K位数字

## 1.题目描述

**给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。**

> 示例 1 ：
>
> 输入：num = "1432219", k = 3
> 输出："1219"
> 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
> 示例 2 ：
>
> 输入：num = "10200", k = 1
> 输出："200"
> 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
> 示例 3 ：
>
> 输入：num = "10", k = 2
> 输出："0"
> 解释：从原数字移除所有的数字，剩余为空就是 0 。
>
>
> 提示：
>
> 1 <= k <= num.length <= 105
> num 仅由若干位数字（0 - 9）组成
> 除了 0 本身之外，num 不含任何前导零

## 2.题目来源

[力扣官网](https://leetcode-cn.com/problems/remove-k-digits/)

## 3.题解(JavaScript)

我们要求得移除k位数的最小数字，可以使用单调栈来解答

假设有两个长度相等的数 a=12345678 b=15345678

判断这两个数的大小就是看它们从高位至低位第一个不同数字的大小

例如5>2，故b>a

我们解答这个题目，需要从左至右遍历字符串，保证栈中的元素是单调递增的

**如果当前遍历的数字大于或者等于栈顶数字 入栈**

**如果当前遍历的数字小于栈顶数字 将栈顶数字出栈**

```javascript
var removeKdigits = function(num, k) {
    //如果k大于或者等于字符串的长度，说明字符串可以全部移除，返回'0'
    if(num.length <= k)
    return '0'
    const stk = []
    let ans = ''
    //遍历num
    for(const ch of num){
        //如果遍历的数字小于栈顶元素，栈顶元素出栈，k-1
        while(k&&ch<stk[stk.length-1]&&stk.length){
            stk.pop()
            k--
        }
        stk.push(ch)
    }
    //如果遍历完之后k仍大于0，我们从栈中移除相应数量的数字
    while(k--){
        stk.pop()
    }
    let flag = 0
    //如果有前置0，则不输出前置0
    for(let i=0;i<stk.length;i++){
        if(stk[i]!=0){
            flag=1
        }
        if(flag===1){
            ans+=stk[i]
        }

    }
    return ans===''?'0':ans
};
```

# 有效的括号

## 1.题目描述

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
```

> ```
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 
> 示例 1：
> 
> 输入：s = "()"
> 输出：true
> 
> 示例 2：
> 
> 输入：s = "()[]{}"
> 输出：true
> 
> 示例 3：
> 
> 输入：s = "(]"
> 输出：false
> 
> 示例 4：
> 
> 输入：s = "([)]"
> 输出：false
> 
> 示例 5：
> 输入：s = "{[]}"
> 输出：true
> 
> 提示：
> 
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成
> 
> ```

## 2.题目来源



[力扣官网](https://leetcode-cn.com/problems/valid-parentheses/)

## 3.题解(使用JavaScript作为编程语言)

解答这个题最好的方法就是栈，我们可以**利用栈的后进先出的特点，依次对比每个括号的有效性**

另外，我们可以**将三种括号作为key和value存入哈希表**中，用来查值

```javascript
var isValid = function(s) {
    if(s.length%2!=0)
        return false
    const stk = []
    //创建map表，右括号作为key，左括号作为value
    const  map = new Map([
        [')','('],
        ['}','{'],
        [']','['],
    ])
    //遍历s
    for(let ch of s){
        
        if(map.has(ch)){
            //如果map存在key的值为ch，并且栈顶元素的值与map对应key的value一样，如果这个括号合法，否则不合法直接return false
            if(!stk.length || stk[stk.length-1] != map.get(ch)){
                return  false
            }
            stk.pop()
        }else{
            //如果map中不存在key的值为ch，则说明此时遍历的是左括号，直接入栈
            stk.push(ch)
        }
    }
    //最后判断栈中元素是否为空，如果为空说明括号都已经匹配成功，返回true
    return stk.length?false:true
}
```

# 整数除法

## 题目描述

给定两个整数 **a** 和 **b** ，求它们的除法的商 **a/b** ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。

示例1:

> ```
> 输入：a = 15, b = 2
> 输出：7
> 解释：15/2 = truncate(7.5) = 7
> ```

示例2:

> ```
> 输入：a = 7, b = -3
> 输出：0
> 解释：7/-3 = truncate(-2.33333..) = -2
> ```

示例3:

> ```
> 输入：a = 0, b = 1
> 输出：0
> ```

示例4:

> ```
> 输入：a = 1, b = 1
> 输出：1
> ```

**提示**:-2^31<=a,b<=2^31-1,b!=0



## 题目来源:

> 剑指offer(专项突击版) [剑指offer|| 001]整数除法
>
> ```
> https://leetcode-cn.com/problems/divide-two-integers/
> ```

## 题解

> 设sum为a除以b的商,a和b的范围是-2^31~2^31,如果按照{a=a-b,sum++},当且仅当a>=b的思路时间复杂度太高，肯定会超时,所以我们应该时循环的次数变得尽可能的少。
>
> 我们可以让b1=b,task=1，累加(b1+b1),直到**b1+b1>a**,此时的b已经是a的**最大可除数**，记录b1累加的次数task，此时b1=task*b，再将a-b1,可以将a拆分成更小的数，将task重置为1,b1=b,继续执行上述操作，最终可以求出a除以b的商
>
> 设test =b,task=1,sum=0,重复执行此操作:b每次累加(b=b+b),task也累加(task=task+task),a=a-test,sum=sum+task,直到a<=test+test,操作结束.再对a和b的大小进行判断，如果此时a<b,则返回sum，如果a=b,返回sum+1
>
> 上述关系可以表示成:**(a-task1×b-task2×b-...taskn×b)/b+task1+task2+...taskn**
>
> 例如:a=60,b=13,a/b=(60-52)/13+4,sum=4.a=70,b=12,a/b=(70-48-12)/12+4+1
>
> 

```javascript
var divide = function(a, b) {
    let num = a
    let sum = 0
    if(a>=0&&b>0){
        if(a>=Math.pow(2,31)-1&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(a>test+test){
                test+=test
                task+=task
            }
            a-=test
            sum+=task
            }
    }else if(a<=0&&b<0){
        if(a<=-Math.pow(2,31)&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = -b
            let task = 1
            if(-a<-b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a>=0&&b<0){
        if(a>=Math.pow(2,31)-1&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<-b){
                return -sum
            }
            if(a==-b){
                return -sum-1
            }
            while(a>Math.abs(test+test)){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a<=0&&b>0){
        if(a<-Math.pow(2,31)&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1

            if(-a<b){
                return -sum
            }
            if(-a==b){
                return -sum-1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }

};
```

# 最长有效括号

## 1.题目描述

```
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```

```
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：
输入：s = ""
输出：0
提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'
```

## 2.题目来源

## 3.题解

解决这道题，我们可以用栈来存取字符串的下标来判断最长有效长度

为了计算有效长度，我们需要在初始时在栈中push -1，因为当计算有有效长度时，如果一对括号的下标分别为0和1，那么求出的有效长度为1-0=1，不符合正确有效长度

如果遍历的字符为左括号，我们将字符的下标入栈

如果遍历的字符为右括号，我们让栈顶元素出栈:

​	1.如果此时栈为空，说明栈中没有含有值为左括号的字符的下标，我们将当前字符下标入栈，用于重置			有效下标

​	2.如果此时栈不为空，我们判断maxlength和i-stack[stack.length-1] （当前计算出来的有效长度）的大			小，并重新赋值

最后返回**maxlength**的值

```javascript
var longestValidParentheses = function(s) {
    const stack = []
    stack.push(-1)//在初始时推入-1
    let maxlength=0
    for(let i = 0 ; i < s.length ; i++){
        if(s[i]==='('){
            stack.push(i)//如果遍历的字符为'('，将其下标入栈
        }else{
            //栈顶元素出栈，用于判断栈中是否含有有效括号的下标
            stack.pop()
            if(!stack.length){
                //如果此时栈为空，则将i入栈，用于重置有效下标
                stack.push(i)
            }else{
                //如果栈不为空，计算maxlength的值
                maxlength = maxlength > (i-stack[stack.length-1]) ? maxlength : (i-stack[stack.length-1])
            }
        }

    }
    return maxlength
}
```

# 随机选取数组元素的时候避免相邻重复

迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换，这个随机位置比当前位置小。这个算法可以保证随机过的位置不会再被随机一次。

```javascript
const swap = (arr,i,j) => { [arr[i],arr[j]] = [arr[j],arr[i]] } //交换数组中的两个位置

function getrandom(arr){

    for (let i = arr.length-1; i >= 0 ; i--) {
        //Math.random随机范围为[0,1),Math.floor向下取整    
        const randomIndex = Math.floor( Math.random()*i)
        console.log(arr[randomIndex]);
         //随机过的位置放后面
        swap(arr,i,randomIndex)
    }
}
const arr = [1,2,3,4,5,6,7,8,9,10]
getrandom(arr)
```

# 二叉树遍历

## 前序遍历

递归法

```javascript
var preorderTraversal = function(root) {
     let res = []
     let a = function (root){
         if(!root)
             return
         res.push(root.val)
         a(root.left)
         a(root.right)
     }
     a(root)
     return  res

};
```

回溯法

```javascript
var preorderTraversal = function(root) {

    let res =[]
    let stk= []
    while(root||stk.length){
        while(root){
            res.push(root.val)
            stk.push(root)
            root = root.left
        }
        root = stk.pop()
        root = root.right
    }
    return res

};
```



## 中序遍历

递归法

```javascript
var inorderTraversal = function(root) {

    let res = [];
    function a(root){
        if(!root) return;
        a(root.left);
        res.push(root.val);
        a(root.right);
    }
    a(root);
    return res;
}
```

回溯法

```javascript
var inorderTraversal = function(root) {

  let res = [];
  let stk = [];
  while(root || stk.length){

      while(root){
          stk.push(root);
          root = root.left;
      }
      root = stk.pop();  
      res.push(root.val);
      root = root.right;
  }
  return res;
}
```



## 后序遍历

递归法

```javascript

var postorderTraversal = function(root) {
     let res = []
     let a=function (root){
        if(!root)
             return
         a(root.left)
         a(root.right)
         res.push(root.val)
     }
     a(root)
     return  res
};
```

回溯法

```javascript
var postorderTraversal = function(root) {
    let res = [];
    let stk = [];
    while(root || stk.length){
        while(root){
            res.push(root.val);
            stk.push(root);
            root = root.right;

        }
        root = stk.pop();
        root = root.left;
        
    }
    let reserveRes = res.reverse()//将中右左翻转为左右中
    return res;
};
```

# 二叉树的最大深度

leetcode(104)

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。

```javascript
var maxDepth = function(root) {
    let max = 0;
    let a = function(root,dept){
        if(!root){
            max = dept > max ? dept : max;
            return;
        }else{
            dept++;
        }
        a(root.left,dept);
        a(root.right,dept);
    }
    a(root,0);
    return max;
};
```

# 相同的树

> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```javascript
var isSameTree = function(p, q) {
    
    let flag = true;
    function isSame(ptree,qtree){

        if(!ptree && !qtree) return;
        if((!ptree && qtree) || (ptree && !qtree)){
            flag = false;
            return;
        } 
        if(ptree.val !== qtree.val){
            flag = false;
            return;
        } 

        isSame(ptree.left,qtree.left);
        isSame(ptree.right,qtree.right);
    
    }
    isSame(p,q);
    return flag;

};
```

# 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**思路**:把根节点左节点作为左树，右节点作为右树,将左树的左节点与右树的右节点对比,左树的右节点与右树的左节点对比,最后返回结果

```javascript
var isSymmetric = function(root) {

   function compareRoot(leftNode,rightNode){
       if(!leftNode && rightNode){
           return false;
       }else if (leftNode && !rightNode){
           return false;
       }else if(leftNode === null && rightNode === null){
           return true;
       }
       else if(leftNode.val !== rightNode.val){
           return false;
       }

        return compareRoot(leftNode.left,rightNode.right) && compareRoot(leftNode.right,rightNode.left)
   }

    if(!root) return true
   return compareRoot(root.left,root.right);


};
```

# 二叉树的最小深度

[ 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

```javascript
var minDepth = function(root) {

    let min = 10001;
    if(!root){
        return 0;
    }else if(root.left === null && root.right !==null){
        getMin(root.right,1);
    }else if(root.right !== null && root.right === null){
        getMin(root.left,1);
    }else if(root.left === null && root.right === null){
        return 1;
    }else{
        getMin(root,0);
    }

    function getMin(node,dept){
        dept++;
        if(node.left === null && node.right === null){
            min = min < dept ? min : dept;
            return;
        }else if(node.left!==null && node.right === null){
            getMin(node.left,dept);
        }else if(node.left === null && node.right !== null){
            getMin(node.right,dept);
        }else if(node.left !==null && node.right !== null){ 
            getMin(node.left,dept);
            getMin(node.right,dept);
        }
      
    }
    // getMin(root,0);
    return min;

};
```

