## 

# 比特位计数

## 题目描述

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例1:

> ```
> 输入: 2
> 输出: [0,1,1]
> ```

示例2:

> ```
> 输入: 5
> 输出: [0,1,1,2,1,2]
> ```

进阶:

- 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？


- 要求算法的空间复杂度为**O(n)**。

- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作

## 题目来源:

> ```
> 剑指offer(专项突击版) [剑指offer|| 003]前n个数字二进制中1的个数
> ```

[力扣 338.比特币计数]: https://leetcode-cn.com/problems/counting-bits/

## 题解

> 为了表述简洁，下文用「一比特数」表示二进制表示中的 1 的数目。

### 解法一 暴力枚举

> 这是我最先想到的方法,两个循环暴力枚举直接出结果，但是这种方法的时间复杂度和空间复杂度都很高.
>
> 定义一个数组，将0~n进行遍历，将循环中的i转换成二进制字符串，然后将二进制字符串分割成数组chars，再对chars进行遍历，如果chars[j]=‘1’,sum++;遍历完之后将sum添加到数组中.



```javascript
var countBits = function(n) {

    let sum = 0;
    let number = [];
    for(let i=0;i<=n;i++ ){
        let value = i.toString(2);
        let chars = value.split('');
        for(let j=0;j<chars.length;j++){
            if(chars[j] == '1')
                sum++;
        }
        number.push(sum);
        sum=0;
    }
    return number

 }
```

### 解法二  Brian Kernighan算法位运算

> 位运算&表示**同1为1**, 令**x&(x-1)**,该运算将x的二进制表示的最后一个1变成0，因此，对 *x* 重复该操作，直到x变成0,则操作次数即为x的「一比特数],例如：令x=10，二进制表示位1010,(x-1)=9.二进制表示为1001,10&9=1000. 1000比1010少了一个1
>
> 对于给定的 n，计算从 0 到 n 的每个整数的「一比特数」的时间都不会超过 )O(logn)，因此总时间复杂度为 O(nlogn)。

```javascript
var countBits = function(n) {
	   const  bits = new Array(n+1).fill(0)
    for(let i=0;i<=n;i++){
        let num = getNumOne(i);
        bits[i] = num;
    }
    return bits;
 }
var getNumOne = function (n){
    let x=0
    while(n>0){
        n&=(n-1);//n&(n-1) = (n-1)
        x++;
    }
    return x
}
```

**时间复杂度**:O(nlogn)。需要对从0到n的每个整数使用计算「一比特数」，对于每个整数计算							「一比特数」的时间都不会超过O(logn)。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法三 动态规划 位运算(最高有效位)

> 当计算 i 的「一比特数」时，如果存在 0 <=j<i，j 的「一比特数」已知，且 i 和 j 相比，i的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。
>
> 上述关系可以表示成: **bits[i]=bits[j]+1**
>
> 对于正整数x，如果可以知道最大的整数y,使得y<=x并且y是2的整数次幂，则y的二进制表示中只有最高位是1，其余都是0，此时称 *y* 为 *x* 的「最高有效位」。**令z=x-y,则bits[x]=bits[z]+bits[y]=bits[z]+1**
>
> 为了判断一个正整数是不是 2 的整数次幂，可以利用方法二中提到的按位与运算的性质,如果y是2的整数次幂,则y&(y-1)=0;由此可见没正整数y是2的正整数次幂，当且仅当y&(y-1)=0
>
> 如果i&(i-1)=0,则令hignBit=i,更新当前的最高有效位
>
> **bits[i]=bits[i-hignBit]+1**
>
> 

```javascript
   const  bits = new Array(n+1).fill(0);
    let hignNum=0;
    for(let i=1;i<=n;i++){
        if((i&(i-1))==0){
            hignNum = i;
        }
        bits[i] = bits[i-hignNum]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法四 动态规划 位运算(设置最低位)

> 定义正整数 x 的「**最低设置位**」为 *x* 的二进制表示中的最低的 1 所在位，例如，10的二进制表示是1010，其最低设置位是2，二进制表示为10
>
> 令y=x&(x-1),则y为将x的最低设置位从1变成0之后的数，显然0<=y<=x,bits[x]=bits[y]+1,
>
> 对于任意正整数x，都有bits[x]=bits[x&(x-1)]+1

```javascript
 const  bits = new Array(n+1).fill(0)
    for(let i=1;i<=n;i++){
        bits[i]=bits[(i&(i-1))]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法五 动态规划 位运算(最低有效位)

> 对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是[x/2],如果bits[x/2]已知，则可以得到bits[x]的值
>
> - 如果 x 是偶数，bits[x]=bits[x>>1]
>
> - 如果 x 是奇数，bits[x]=bits[x>>1]+1
>
> 判断x的奇偶可以通过x&1得到，如果为奇数，x&1=1，反之为0
>
> 则 bits[x]=**bits[x>>1]+(x&1)**



```javascript
    const bits = new Array(n+1).fill(0);
    for(let i = 1;i<=n;i++){
        bits[i] = bits[i>>1]+(i&1)
    }
    return  bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

# 二进制加法

## 1.题目描述

```
给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。
```

```
示例 1:
输入: a = "11", b = "10"
输出: "101"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。
```

## 2.题目来源

> 剑指offer(专项突击版) [剑指offer|| 002]二进制加法

[力扣官网](https://leetcode-cn.com/problems/add-binary/)

## 3.题解

**解答这道题的问题是两个数的加法运算是从低位到高位的,我们要将字符串从后往前遍历，最后求得的结果再翻转**

**另外我们还要考虑两个字符串长度不一样的情况，遍历时我们需要判断字符串是否遍历完成，这样才能获取正确结果**

下方代码中，**ans**表示**结果字符串**，**ca**表示进**位的值**，**sum**表示**当前遍历位的值**，**如果sum>=2,我们需要往后进一位，遍历到下一个值时，我们需要让sum加上遍历上一个值是所进的位数值**

```javascript
var addBinary = function(a, b) {
    let ans =''
    let ca = 0
    for(let i =a.length-1,j=b.length-1;i>=0||j>=0;i--,j--){
        let sum = ca
        sum += i>=0 ? parseInt(a[i]) : 0//如果a遍历完成了,sum不再加a[i]
        sum += j>=0 ? parseInt(b[j]) : 0//如果b遍历完成了,sum不再加b[i]
        ans += sum % 2 //将当前位的值加入到ans中，如果sum=2，则当前位为0
        ca = Math.floor(sum / 2)//向下取整sum/2,如果sum=2，则进位加1
    }
    ans += ca>0? 1 : ''//最后判断进位的值，如果ca>0，结果应该加进位1，否则不变
    return ans.split('').reverse().join('')//最后将字符串进行反转求得结果
};
```

# 移除K位数字

## 1.题目描述

**给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。**

> 示例 1 ：
>
> 输入：num = "1432219", k = 3
> 输出："1219"
> 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
> 示例 2 ：
>
> 输入：num = "10200", k = 1
> 输出："200"
> 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
> 示例 3 ：
>
> 输入：num = "10", k = 2
> 输出："0"
> 解释：从原数字移除所有的数字，剩余为空就是 0 。
>
>
> 提示：
>
> 1 <= k <= num.length <= 105
> num 仅由若干位数字（0 - 9）组成
> 除了 0 本身之外，num 不含任何前导零

## 2.题目来源

[力扣官网](https://leetcode-cn.com/problems/remove-k-digits/)

## 3.题解(JavaScript)

我们要求得移除k位数的最小数字，可以使用单调栈来解答

假设有两个长度相等的数 a=12345678 b=15345678

判断这两个数的大小就是看它们从高位至低位第一个不同数字的大小

例如5>2，故b>a

我们解答这个题目，需要从左至右遍历字符串，保证栈中的元素是单调递增的

**如果当前遍历的数字大于或者等于栈顶数字 入栈**

**如果当前遍历的数字小于栈顶数字 将栈顶数字出栈**

```javascript
var removeKdigits = function(num, k) {
    //如果k大于或者等于字符串的长度，说明字符串可以全部移除，返回'0'
    if(num.length <= k)
    return '0'
    const stk = []
    let ans = ''
    //遍历num
    for(const ch of num){
        //如果遍历的数字小于栈顶元素，栈顶元素出栈，k-1
        while(k&&ch<stk[stk.length-1]&&stk.length){
            stk.pop()
            k--
        }
        stk.push(ch)
    }
    //如果遍历完之后k仍大于0，我们从栈中移除相应数量的数字
    while(k--){
        stk.pop()
    }
    let flag = 0
    //如果有前置0，则不输出前置0
    for(let i=0;i<stk.length;i++){
        if(stk[i]!=0){
            flag=1
        }
        if(flag===1){
            ans+=stk[i]
        }

    }
    return ans===''?'0':ans
};
```

# 有效的括号

## 1.题目描述

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
```

> ```
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 
> 示例 1：
> 
> 输入：s = "()"
> 输出：true
> 
> 示例 2：
> 
> 输入：s = "()[]{}"
> 输出：true
> 
> 示例 3：
> 
> 输入：s = "(]"
> 输出：false
> 
> 示例 4：
> 
> 输入：s = "([)]"
> 输出：false
> 
> 示例 5：
> 输入：s = "{[]}"
> 输出：true
> 
> 提示：
> 
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成
> 
> ```

## 2.题目来源



[力扣官网](https://leetcode-cn.com/problems/valid-parentheses/)

## 3.题解(使用JavaScript作为编程语言)

解答这个题最好的方法就是栈，我们可以**利用栈的后进先出的特点，依次对比每个括号的有效性**

另外，我们可以**将三种括号作为key和value存入哈希表**中，用来查值

```javascript
var isValid = function(s) {
    if(s.length%2!=0)
        return false
    const stk = []
    //创建map表，右括号作为key，左括号作为value
    const  map = new Map([
        [')','('],
        ['}','{'],
        [']','['],
    ])
    //遍历s
    for(let ch of s){
        
        if(map.has(ch)){
            //如果map存在key的值为ch，并且栈顶元素的值与map对应key的value一样，如果这个括号合法，否则不合法直接return false
            if(!stk.length || stk[stk.length-1] != map.get(ch)){
                return  false
            }
            stk.pop()
        }else{
            //如果map中不存在key的值为ch，则说明此时遍历的是左括号，直接入栈
            stk.push(ch)
        }
    }
    //最后判断栈中元素是否为空，如果为空说明括号都已经匹配成功，返回true
    return stk.length?false:true
}
```

# 整数除法

## 题目描述

给定两个整数 **a** 和 **b** ，求它们的除法的商 **a/b** ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。

示例1:

> ```
> 输入：a = 15, b = 2
> 输出：7
> 解释：15/2 = truncate(7.5) = 7
> ```

示例2:

> ```
> 输入：a = 7, b = -3
> 输出：0
> 解释：7/-3 = truncate(-2.33333..) = -2
> ```

示例3:

> ```
> 输入：a = 0, b = 1
> 输出：0
> ```

示例4:

> ```
> 输入：a = 1, b = 1
> 输出：1
> ```

**提示**:-2^31<=a,b<=2^31-1,b!=0



## 题目来源:

> 剑指offer(专项突击版) [剑指offer|| 001]整数除法
>
> ```
> https://leetcode-cn.com/problems/divide-two-integers/
> ```

## 题解

> 设sum为a除以b的商,a和b的范围是-2^31~2^31,如果按照{a=a-b,sum++},当且仅当a>=b的思路时间复杂度太高，肯定会超时,所以我们应该时循环的次数变得尽可能的少。
>
> 我们可以让b1=b,task=1，累加(b1+b1),直到**b1+b1>a**,此时的b已经是a的**最大可除数**，记录b1累加的次数task，此时b1=task*b，再将a-b1,可以将a拆分成更小的数，将task重置为1,b1=b,继续执行上述操作，最终可以求出a除以b的商
>
> 设test =b,task=1,sum=0,重复执行此操作:b每次累加(b=b+b),task也累加(task=task+task),a=a-test,sum=sum+task,直到a<=test+test,操作结束.再对a和b的大小进行判断，如果此时a<b,则返回sum，如果a=b,返回sum+1
>
> 上述关系可以表示成:**(a-task1×b-task2×b-...taskn×b)/b+task1+task2+...taskn**
>
> 例如:a=60,b=13,a/b=(60-52)/13+4,sum=4.a=70,b=12,a/b=(70-48-12)/12+4+1
>
> 

```javascript
var divide = function(a, b) {
    let num = a
    let sum = 0
    if(a>=0&&b>0){
        if(a>=Math.pow(2,31)-1&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(a>test+test){
                test+=test
                task+=task
            }
            a-=test
            sum+=task
            }
    }else if(a<=0&&b<0){
        if(a<=-Math.pow(2,31)&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = -b
            let task = 1
            if(-a<-b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a>=0&&b<0){
        if(a>=Math.pow(2,31)-1&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<-b){
                return -sum
            }
            if(a==-b){
                return -sum-1
            }
            while(a>Math.abs(test+test)){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a<=0&&b>0){
        if(a<-Math.pow(2,31)&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1

            if(-a<b){
                return -sum
            }
            if(-a==b){
                return -sum-1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }

};
```

# 最长有效括号

## 1.题目描述

```
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```

```
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：
输入：s = ""
输出：0
提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'
```

## 2.题目来源

## 3.题解

解决这道题，我们可以用栈来存取字符串的下标来判断最长有效长度

为了计算有效长度，我们需要在初始时在栈中push -1，因为当计算有有效长度时，如果一对括号的下标分别为0和1，那么求出的有效长度为1-0=1，不符合正确有效长度

如果遍历的字符为左括号，我们将字符的下标入栈

如果遍历的字符为右括号，我们让栈顶元素出栈:

​	1.如果此时栈为空，说明栈中没有含有值为左括号的字符的下标，我们将当前字符下标入栈，用于重置			有效下标

​	2.如果此时栈不为空，我们判断maxlength和i-stack[stack.length-1] （当前计算出来的有效长度）的大			小，并重新赋值

最后返回**maxlength**的值

```javascript
var longestValidParentheses = function(s) {
    const stack = []
    stack.push(-1)//在初始时推入-1
    let maxlength=0
    for(let i = 0 ; i < s.length ; i++){
        if(s[i]==='('){
            stack.push(i)//如果遍历的字符为'('，将其下标入栈
        }else{
            //栈顶元素出栈，用于判断栈中是否含有有效括号的下标
            stack.pop()
            if(!stack.length){
                //如果此时栈为空，则将i入栈，用于重置有效下标
                stack.push(i)
            }else{
                //如果栈不为空，计算maxlength的值
                maxlength = maxlength > (i-stack[stack.length-1]) ? maxlength : (i-stack[stack.length-1])
            }
        }

    }
    return maxlength
}
```

# 随机选取数组元素的时候避免相邻重复

迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换，这个随机位置比当前位置小。这个算法可以保证随机过的位置不会再被随机一次。

```javascript
const swap = (arr,i,j) => { [arr[i],arr[j]] = [arr[j],arr[i]] } //交换数组中的两个位置

function getrandom(arr){

    for (let i = arr.length-1; i >= 0 ; i--) {
        //Math.random随机范围为[0,1),Math.floor向下取整    
        const randomIndex = Math.floor( Math.random()*i)
        console.log(arr[randomIndex]);
         //随机过的位置放后面
        swap(arr,i,randomIndex)
    }
}
const arr = [1,2,3,4,5,6,7,8,9,10]
getrandom(arr)
```

# 二叉树遍历

## 前序遍历

递归法

```javascript
var preorderTraversal = function(root) {
     let res = []
     let a = function (root){
         if(!root)
             return
         res.push(root.val)
         a(root.left)
         a(root.right)
     }
     a(root)
     return  res

};
```

回溯法

```javascript
var preorderTraversal = function(root) {

    let res =[]
    let stk= []
    while(root||stk.length){
        while(root){
            res.push(root.val)
            stk.push(root)
            root = root.left
        }
        root = stk.pop()
        root = root.right
    }
    return res

};
```



## 中序遍历

递归法

```javascript
var inorderTraversal = function(root) {

    let res = [];
    function a(root){
        if(!root) return;
        a(root.left);
        res.push(root.val);
        a(root.right);
    }
    a(root);
    return res;
}
```

回溯法

```javascript
var inorderTraversal = function(root) {

  let res = [];
  let stk = [];
  while(root || stk.length){

      while(root){
          stk.push(root);
          root = root.left;
      }
      root = stk.pop();  
      res.push(root.val);
      root = root.right;
  }
  return res;
}
```



## 后序遍历

递归法

```javascript

var postorderTraversal = function(root) {
     let res = []
     let a=function (root){
        if(!root)
             return
         a(root.left)
         a(root.right)
         res.push(root.val)
     }
     a(root)
     return  res
};
```

回溯法

```javascript
var postorderTraversal = function(root) {
    let res = [];
    let stk = [];
    while(root || stk.length){
        while(root){
            res.push(root.val);
            stk.push(root);
            root = root.right;

        }
        root = stk.pop();
        root = root.left;
        
    }
    let reserveRes = res.reverse()//将中右左翻转为左右中
    return res;
};
```



# 二叉树的最大深度

leetcode(104)

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。

```javascript
var maxDepth = function(root) {
    let max = 0;
    let a = function(root,dept){
        if(!root){
            max = dept > max ? dept : max;
            return;
        }else{
            dept++;
        }
        a(root.left,dept);
        a(root.right,dept);
    }
    a(root,0);
    return max;
};
```

# 相同的树

> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```javascript
var isSameTree = function(p, q) {
    
    let flag = true;
    function isSame(ptree,qtree){

        if(!ptree && !qtree) return;
        if((!ptree && qtree) || (ptree && !qtree)){
            flag = false;
            return;
        } 
        if(ptree.val !== qtree.val){
            flag = false;
            return;
        } 

        isSame(ptree.left,qtree.left);
        isSame(ptree.right,qtree.right);
    
    }
    isSame(p,q);
    return flag;

};
```

# 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**思路**:把根节点左节点作为左树，右节点作为右树,将左树的左节点与右树的右节点对比,左树的右节点与右树的左节点对比,最后返回结果

```javascript
var isSymmetric = function(root) {

   function compareRoot(leftNode,rightNode){
       if(!leftNode && rightNode){
           return false;
       }else if (leftNode && !rightNode){
           return false;
       }else if(leftNode === null && rightNode === null){
           return true;
       }
       else if(leftNode.val !== rightNode.val){
           return false;
       }

        return compareRoot(leftNode.left,rightNode.right) && compareRoot(leftNode.right,rightNode.left)
   }

    if(!root) return true
   return compareRoot(root.left,root.right);


};
```

# 二叉树的最小深度

[ 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

```javascript
var minDepth = function(root) {

    let min = 10001;
    if(!root){
        return 0;
    }else if(root.left === null && root.right !==null){
        getMin(root.right,1);
    }else if(root.right !== null && root.right === null){
        getMin(root.left,1);
    }else if(root.left === null && root.right === null){
        return 1;
    }else{
        getMin(root,0);
    }

    function getMin(node,dept){
        dept++;
        if(node.left === null && node.right === null){
            min = min < dept ? min : dept;
            return;
        }else if(node.left!==null && node.right === null){
            getMin(node.left,dept);
        }else if(node.left === null && node.right !== null){
            getMin(node.right,dept);
        }else if(node.left !==null && node.right !== null){ 
            getMin(node.left,dept);
            getMin(node.right,dept);
        }
      
    }
    // getMin(root,0);
    return min;

};
```

# 二叉树大的层序遍历

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**思路**：通过一个 while 循环控制从上向下一层层遍历，for 循环控制每一层从左向右遍历：用一个数组存储当前遍历层级的二叉树节点,另一个数组存储这层的二叉树节点的值

```javascript
var levelOrder = function(root) {

    if(!root) return [];
    let queen = [root];
    let res = [];
    while(queen.length){

        let currentLength = queen.length;
        res.push([]);

        for(let i = 0 ;i <currentLength; i++){
            
            let node = queen.shift();
            res[res.length-1].push(node.val);
            
            node.left && queen.push(node.left);
            node.right && queen.push(node.right);
        }

    }
    return res;
};
```

# 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

```javascript
var merge = function(nums1, m, nums2, n) {

    for(let i = m,j=0;i<nums1.length;i++,j++){
        nums1[i] = nums2[j];
    }
    nums1.sort((a,b)=>{
        return a-b;
    });
    
};
```

# 多树元素

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```javascript
var majorityElement = function(nums) {
   if(nums.length <= 2) return nums[0];
   nums.sort((a,b)=>{
       return a-b;
   })
   return nums[parseInt(nums.length/2)];
};
```

# 回文链表

https://leetcode-cn.com/problems/palindrome-linked-list/

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

```javascript
var isPalindrome = function(head) {
   
   let arr1 = [];
   let arr2 = [];
   while(head){
       arr1.push(head.val)
       head = head.next;
   }
   arr2 = arr1.reverse();
   for(let i =0,j=arr2.length-1;i<arr1.length,j>=0;i++,j--){
       if(arr1[i] !== arr2[j]) return false;
   }
   return true;
};
```

# 链表中倒数第K个节点

[ 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

```javascript
var getKthFromEnd = function(head, k) {
	//先遍历一遍链表获取链表的长度,然后再遍历一遍链表就ok了
    let length = 1;
    let i = 1;
    let head1 = head;
    while(head){
        head = head.next;
        length++;
    }
    while(head1){
        if(length - i === k) return head1;
        i++;
        head1 = head1.next;
    }

};
```

# 环形链表

[ 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

思路:定义快指针和慢指针,快指针一次走两步，慢指针一次走一步,如果最终快指针等于慢指针,说明快指针比慢指针多走了一圈了,存在环

```javascript
var hasCycle = function(head) {
    
    let slow = head;
    let fast = head;
    while(fast && fast.next){
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){
            return true;
        }
    }
    return false;

};

```



# 斐波那契数列

[ 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

思路:建立一个数组,将所有的情况通过一次循环存储起来,这样子时间复杂度为O(n),如果通过递归,则需要O(2^n)

```javascript
var fib = function(n) {

    if(n === 0) return 0;
    let dp = new Array(n+1).fill(0);
    dp[1] = 1;
    for(let i = 2;i <= n;i++){
        dp[i] = (dp[i-1]  + dp[i-2]) % (1e9+7);
    }
    return dp[n] ;
   
};
```

# 最少的硬币数目

[最少的硬币数目](https://leetcode-cn.com/problems/gaM7Ch/)

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
> 你可以认为每种硬币的数量是无限的。
>

 

思路：记录每一种情况,并用数组存起来(避免递归多层造成超时)

```javascript
var coinChange = function(coins, amount) {

    let dp = new Array(amount+1).fill(amount+1);//数组初始值一定要大于amount，否则对比最小值时会出错
    dp[0] = 0;
    for(let i=1;i<dp.length;i++){
        for( let coin of coins){
            if(i - coin < 0) continue;
            dp[i] = Math.min(dp[i],dp[i-coin]+1)//这里如果数组初始值小于amount，那么dp[i]就不会变 
        }
    }
    return (dp[amount] === amount+1) ? -1 : dp[amount]

};
```

# 包含min函数的栈

[包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

思路：创建一个普通栈和一个最小栈,每当普通站push时,最小栈push当前普通栈中最小值

```javascript
var MinStack = function() {
    this.stk = [];
    this.stk_min = [Infinity];
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    this.stk_min.push(Math.min(this.stk_min[this.stk_min.length-1],x))
    this.stk.push(x);
    
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.stk.pop()
    this.stk_min.pop();
};  

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stk[this.stk.length-1]
};

/**
 * @return {number}
 */
MinStack.prototype.min = function() {
    return this.stk_min[this.stk_min.length-1];
};
```

# 用两个栈实现队列

[ 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
>

思路:创建一个输入栈和一个输出栈,每次插入时往输入栈中push，删除时判断输出栈是否有元素,如果没有就将输入栈中元素倒序push进输出栈中(因为队列是先进先出，栈是后进先出,栈顶元素其实是队列尾部元素,所以要倒序转换一下),然后删除栈顶元素

```javascript
var CQueue = function() {
        this.putStk = [];
        this.outStk = [];
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
    this.putStk.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
    
    if(!this.outStk.length){

        if(!this.putStk.length) return -1;

        while(this.putStk.length){
            this.outStk.push(this.putStk.pop())
        }
    }

    return this.outStk.pop();
};
```

# 青蛙跳台阶问题

[青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> 思路:用dp将所有状态储存起来然后输出
>

```javascript
var numWays = function(n) {
    let dp = new Array(n+1).fill(-10);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    for(let i=3;i<=n;i++){
        
        dp[i] = (dp[i-1]+dp[i-2])%(1e9+7);


    }
    return dp[n]
};
```



# 反转链表

[反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

迭代法

思路:用一个变量存放当前节点的后一个节点,然后将当前节点的next指向它的前一个节点

```javascript
var reverseList = function(head) {
    let pre =null;
    let curr = head;
    while(curr){
        let next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
};
```

递归

思路:

```javascript
var reverseList = function(head) {
    
    function  reverse(head){
        
        if(head === null || head.next === null){//如果遍历到了末尾节点
            return head;
        }
        let last = reverse(head.next);

        head.next.next = head;
        head.next = null;

        return last;
    }

    return reverse(head);
};
```

# 反转链表Ⅱ

[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

> 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
> 
>

```javascript
var reverseBetween = function(head, left, right) {

    if(left === 1){
        return reverse(head,right);
    }

    head.next = reverseBetween(head.next,left-1,right-1);//将反转链表的前一个节点与反转链表拼接

    return head;


    

};
let success = null;
function reverse(head,n){

    if(n === 1){
        success = head.next;//获取反转链表的后一个节点
        return head;
    }

    let last = reverse(head.next,n-1);
    head.next.next = head;
    head.next = success;

    return last;
}
```

# 替换空格

[替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

思路:双指针

```javascript
var replaceSpace = function(s) {

    let arr = Array.from(s);
    let count = 0;
    
    for(let i=0;i<arr.length;i++){
        if(arr[i] === ' ') count++;
    }

    let left = arr.length-1;//快指针
    let right = left + count * 2;//慢指针

    while(left >= 0){//开始遍历数组
        if(arr[left] === ' '){
            arr[right--] = '0';
            arr[right--] = '2';
            arr[right--] = '%';
            left--;
        }else{
            arr[right--] = arr[left--];
        }
        
        
    }
  
    return arr.join('');
};
```

js封装函数

```javascript
var replaceSpace = function(s) {

	return replaceAll(' ','#20')
};
```

# 左旋转字符串

[左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```javascript
var reverseLeftWords = function(s, n) {

    let arr = Array.from(s);

    let leftArr = [];
    let rightArr = [];
    for(let i=0;i<arr.length;i++){
        if(i < n){
            leftArr.push(arr[i]);
            continue;
        } 
        rightArr.push(arr[i]);
    }
    return [...rightArr,...leftArr].join('');
};
```

# 数组中重复的数字

[ 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

> 找出数组中重复的数字。
>
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字

思路:由于数字大小的范围已经确定,可以使用**桶排序**的思路解决问题

```javascript
var findRepeatNumber = function(nums) {

    let arr = new Array(nums.length).fill(0);

    for(let i=0;i<nums.length;i++){
        if(arr[nums[i]] != 0) return nums[i];
       
        arr[nums[i]]++;
        
    }


};
```

# 从上到下打印二叉树

[从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```javascript
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
```

思路:再层序遍历基础上加一个奇偶数判断即可

```javascript
var levelOrder = function(root) {

    if(!root) return [];

    let queen = [root];
    let res = [];
    let piles = 1;
    while(queen.length){
        
        let queenLength = queen.length;
        res.push([]);


        for(let i=0;i<queenLength;i++){
            
            let node = queen.shift();

            res[res.length-1].push(node.val);

            node.left && queen.push(node.left)
            node.right && queen.push(node.right)

        }

        if(piles % 2 === 0){
            res[res.length-1].reverse();
        }
        piles++;

       
    }
    return res;
};
```

# 二叉树的镜像

[二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

思路：递归每一个节点,将这个节点的左右子节点替换

```javascript
var mirrorTree = function(root) {

    if(root === null) return null;

    let left = mirrorTree(root.left);
    let right = mirrorTree(root.right);

    root.left = right;
    root.right = left;

    return root;
   

};
```

# 股票的最大利润

[股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

思路:dp找出状态转移方程:`dp[n] = max(prices[i]-price[i-1],prices[i]-prices[i-1]+dp[i-1])`,dp[0]=0;

```javascript
var maxProfit = function(prices) {

    if(!prices.length) return 0;

    let dp = new Array(prices.length).fill(0);
    dp[0] = 0;

    for(let i=1;i<dp.length;i++){

        dp[i] = Math.max(prices[i]-prices[i-1],prices[i]-prices[i-1]+dp[i-1]);

    }

    dp.sort((a,b)=>{
        return a-b;
    })

    return dp[dp.length-1];


};
```

# 连续子数组的最大和

[连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

思路:动态规划

```javascript
var maxSubArray = function(nums) {

    let dp = new Array(nums.length).fill(0);

    dp[0] = nums[0];
    for(let i=1;i<dp.length;i++){
        dp[i] =  Math.max(dp[i-1]+nums[i],nums[i]);
    }
    dp.sort((a,b) => a-b);
    return dp[dp.length-1];

};
```

# 礼物的最大价值

[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 思路:dp创建二维数组,存储棋盘中每一格所能拿到的最大价值,注意礼物的价值是大于0的所以可以少考虑很多东西,状态转移方程是`dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];`

```javascript
var maxValue = function(grid) {


    let dp = new Array(grid.length+1).fill(0).map(()=> new Array(grid[0].length+1).fill(0));
    
    dp[1][1] = grid[0][0];

    for(let i=1;i<=grid.length;i++){
        for(let j=1;j<=grid[0].length;j++){
            
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];
        }
    }

    return dp[grid.length][grid[0].length];

};
```

# 第一个只出现一次的字符

[第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

思路:使用map存储键值对,key为字符串的字符,value为这个键值对的key是否有多个,如果为一个，value为true，如果大于1个，value为false

```javascript
var firstUniqChar = function(s) {


    let arr = s.split('')
   
    let map = new Map();

    for(let c of arr){
        map.set(c , !map.has(c))
    }
    for(let c of arr){
        if(map.get(c)) return c
    }
    return ' '

};

```

# 把数字翻译成字符串

[把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

> 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
>

 思路:如果XiXi-1可以被翻译,则可以将XiXi-1当成一个整体,那么此时翻译方法有f(n-2)种,如果不当成一个整体，拆开来看,有f(n-1)种,所以可以被翻译时f(n)=f(n-1)+f(n-2),不可以被翻译时,f(n)=f(n-1)

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203291717973.png)

```javascript
var translateNum = function(num) {


    let str = num.toString();

    let dp = new Array(str.length).fill(0);
    

    dp[0] = 1;
    dp[1] = (str[0]+str[1]) - '0' <=25 ? 2 : 1 ;

    for(let i =2;i<str.length;i++){

        if(str[i-1] !== '0'){
            dp[i] = (str[i-1]+str[i]) - '0' <= 25 ? (dp[i-1]+dp[i-2]) : dp[i-1]
        }else{
            dp[i] = dp[i-1];
        }
        
    }

    return dp[str.length-1];
};
```

# 最长不含重复字符的子字符串

[最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

> 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

思路:hashmap+双指针,遍历字符串,每当发现map中存在当前字符,就更新左指针，最终根据左右指针的之差获得最长子字符串的长度

```javascript
var lengthOfLongestSubstring = function(s) {

    let map = new Map();
    let res = 0;
    let left = -1;
    for(let right=0;right<s.length;right++){
        
        if(map.has(s[right])){

            left = Math.max(left,map.get(s[right]));//更新左指针

        }

        map.set(s[right],right);
        res = Math.max(res,right-left);
       
    }    

    return res;

};

```

# 二维数组中的查找

[二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:

若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。

```javascript
var findNumberIn2DArray = function(matrix, target) {

    if(!matrix.length) return false;
    let i = 0 , j = matrix[0].length-1;

    while(i < matrix.length && j >=0){
        if(matrix[i][j] === target){
            return true;
        }else if(matrix[i][j] < target){
            i++;
        }else{
            j--;
        }
    }
    return false;

};
```

# N皇后问题

js深浅拷贝恶心死

```javascript

 var solveNQueens = function(n) {

    let res = [];
    let board = new Array(n).fill(0).map(()=> new Array(n).fill('.'));


        //遍历每一种可能性
        const backtrack = (board,row)=>{
        

            if(row === board.length){

                // let board2 = JSON.parse(JSON.stringify(board1)); 
                let board1 = board.slice(); 
                for (let i = 0; i < n; i++) {
                    board1[i] = board1[i].join(''); // 将每一行拼成字符串
                }
                res.push(board1);
                return;
            }  


            for(let i=0;i<board.length;i++){

                if(!isValid(board,row,i)){
                    continue;
                }

                board[row][i] = 'Q';

                backtrack(board,row + 1);

                board[row][i] = '.';

            }


        }

        // 判断此位置放置皇后是否合法
        const isValid = (board1,row,col) =>{//row为行,col为列

            //判断列是否有皇后
            for(let i=row-1;i>=0;i--){
                if(board1[i][col] === 'Q'){
                    return false;
                }
            }
    
            //判断左上斜列是否有皇后
            for(let i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
                if(board1[i][j] === 'Q'){
                    return false;
                }
            }
            //判断右上斜列是否有皇后
            for(let i=row-1,j=col+1;i>=0&&j<n;i--,j++){
                if(board1[i][j] === 'Q'){
                    return false;
                }
            }
    
            return true;
        }
    

        backtrack(board,0);

        return res;
    };
   
```

# 合并两个有序链表

[合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

> 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

思路：递归,如果`l1.val<l2.val`,则将`l1.next`与`l2`合并,如果`l2.val<=l1.val`,则将`l2.next`与`l1`合并,递归结束条件是`！l1`或者`！l2`

```javascript
var mergeTwoLists = function(l1, l2) {

    function mergeTwoQueens(l1,l2){

        if(!l2){
            return l1;
        }else if(!l1){
            return l2;
        }

        if(l1.val <= l2.val){

            l1.next = mergeTwoQueens(l1.next,l2)
            return l1;

        }else if(l1.val > l2.val){
            l2.next = mergeTwoQueens(l1,l2.next)
            return l2;
        }



    }
    return mergeTwoQueens(l1,l2);

};


```

# 调整数组顺序使奇数位于偶数前面

[调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
>
> 

思路:双指针,left指针累加，right指针累减,共有四种不同情况,分别判断就ok

```javascript
var exchange = function(nums) {

    let right = nums.length-1;
    let left = 0;

    while(left < right){

        if(nums[left] % 2 === 0 && nums[right] % 2 !== 0){//  left偶数 right奇数 合法交换
            [nums[left],nums[right]] = [nums[right],nums[left]];
        }else if (nums[left] % 2 === 0 && nums[right] % 2 === 0){// left偶数 right偶数
            right--;
        }else if (nums[left] % 2 !== 0 && nums[right] % 2 === 0){// left奇数 right偶数
            left++;
            right--;
        }else{
            left++;

        }


    }

    
    return nums;

};
```

# 和为s的两个数字

[和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

> 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

思路:left指针和right指针,当`nums[left]+nums[right]>target,right--`,

`nums[left]+nums[right]<target,left++`,否则返回正确值

```javascript
var twoSum = function(nums, target) {

  let left = 0;
  let right = nums.length-1;

  while(left < right){

      if(nums[left] + nums[right] > target){
          right--;
      }else if (nums[left] + nums[right] < target){
          left++;
      }else{
          return [nums[left],nums[right]];
      }

  }

};
```

# 翻转单词顺序

[翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

```
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

思路1:字符串切割,将首尾两端空格去掉之后转成数组,然后遍历数组，每次遍历到的值用字符串累加

```javascript
var reverseWords = function(s) {

    let arr = s.trim().split(' ')
    let str = ''
    arr.reverse();

    for(let i =0;i<arr.length;i++){

        if( arr[i] === '') continue;

        if(i !== arr.length-1){
            str  = str + arr[i] + ' ';
        }else{
            str = str + arr[i];
        }
        
    }

    return str

};
```

思路二：双指针,两个指针从字符串右侧开始移动，快指针移到了空格时候,用slice()切割字符串并将单词移入res中，具体看代码

```javascript
var reverseWords = function(s) {

    let str = s.trim();
    let res = [];

    let fast = str.length-1;
    let slow = str.length-1;

    while(fast >= 0){

        while(fast >= 0 && str[fast] !== ' '){
            fast--;
        }
        res.push(str.slice(fast+1,slow+1));
        while( fast >= 0 && str[fast] === ' '){
           fast--;
        }
        slow = fast;


    }

    return res.join(' ')

};


```

# 树的子结构

[树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
>
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。

思路:回溯,isSubStructure函数负责遍历树A的每个节点,isValid函数负责判断当前A树的节点与B树是否相同

```javascript
var isSubStructure = function(A, B) {

    return (A !== null && B !== null) && (isValid(A,B)|| isSubStructure(A.left,B) || isSubStructure(A.right,B)   )

};

 function isValid(tree,childTree){

        if(!childTree) return true;

        if(!tree) return false;

        if(tree.val !== childTree.val){
            return false;
        }

        return isValid(tree.left,childTree.left) && isValid(tree.right,childTree.right);
        
        

    }

```

# 矩阵中的路径

[矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

思路:遍历棋盘中每个格子,然后用dfs寻找当前格子和周围的格子能不能组成目标单词,要注意的是遍历过的格子不能再遍历

```javascript
var exist = function(board, word) {


    function dfs(i,j,k){

        if(i<0 || i>board.length-1 || j<0 || j>board[0].length-1 || board[i][j] !== word[k]) return false;
        if(k === word.length-1) return true;

        board[i][j] = ' ';
        
        let res = dfs(i+1,j,k+1) || dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i,j-1,k+1);
        
        board[i][j] = word[k];
        
        return res;

    }


    for(let i=0;i<board.length;i++){
        for(let j=0;j<board[0].length;j++){

            if(dfs(i,j,0)) return true;
            

        }
    }

    return false;

};
```

# 二叉搜索树的第k大节点

[二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

思路:用回溯法将每个节点的值存在数组中,然后将数组排序,再输出即可

```javascript
var kthLargest = function(root, k) {

    let res = [];
    let stk = [];

    while(root || stk.length){

        while(root){

            res.push(root.val);
            stk.push(root);
     
            root = root.left;

        }

        root = stk.pop();
        root = root.right;

    }

    res.sort((a,b)=> a-b)

    return res[res.length-k];

};
```

# 扑克牌中的顺子

[扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

> 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
>

思路:用数组把大小王存起来就行了

```javascript
var isStraight = function(nums) {

  
    let kingArr = [];//用来存储大小王
    nums.sort((a,b) => a-b);

    while(nums[0] == 0){
        
        kingArr.push(nums.shift())
    }

    for(let i=1;i<nums.length;i++){

        if(nums[i] -1 !== nums[i-1]){

            let diff = nums[i] - nums[i-1] -1;//获取两个不相隔数字的差
            
            while(kingArr.length){

                if(diff === 0 )break;
                diff--;
                kingArr.pop();

            }
            if(diff != 0) return false;

        }

    }

    return true;



};
```

# 把数组排成最小的数

[把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

> 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

思路:判断两个数哪个在前哪个在后的规则是:`如果x+y<y+x，x在前，y在后`，然后就快排就好了

```javascript
var minNumber = function(nums) {

   
    function quickSort(arr){

        if(!arr.length) return arr;

        let left = [];
        let right = [];

        let basic = arr.shift();
        
        for(let i=0;i<arr.length;i++){

            let strNum = arr[i].toString();
            
            if(strNum + basic  < basic + strNum ){
                left.push(arr[i]);
            }else{
                right.push(arr[i]);
            }
        }



        return quickSort(left).concat(basic,quickSort(right));
    }


    return quickSort(nums).join('');

};
```

# 最小的k个数

[最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

> 输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

思路:快排

```javascript
var getLeastNumbers = function(arr, k) {
    function quickSort(arr){

        if(!arr.length) return arr;

        let left = [];
        let right = [];
        let basis = arr.shift();


        for(let i=0;i<arr.length;i++){

            if(arr[i] < basis){
                left.push(arr[i]);
            }else{
                right.push(arr[i]);
            }


        }

        return quickSort(left).concat(basis,quickSort(right));


    }
    
    let res = quickSort(arr);
    let resReverse = [];
    
    for(let i=0;i<k;i++){

        resReverse.push(res[i])

    }
    return resReverse;

};
```

# 二叉树中和为某一个值的路径

[二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

思路:回溯

```javascript
var pathSum = function(root, target) {

    let path = [];
    let res = [];
    function recur(root,tar){

        if(!root) return;

        path.push(root.val);

        tar -= root.val;

        if(tar ===0 && !root.left && !root.right){

            res.push(path.slice());//阻止浅拷贝bug

        }

        recur(root.left,tar);
        recur(root.right,tar);

        path.pop();



    }

    recur(root,target);
    
    return res;


};

```

# 糕点

https://www.nowcoder.com/test/question/10661f4d02564ba686bcba4645e0a029?pid=28665338&tid=55102676

> 小团的蛋糕铺长期霸占着美团APP中“蛋糕奶茶”栏目的首位，因此总会吸引各路食客前来探店。
>
> 小团一天最多可以烤n个蛋糕，每个蛋糕有一个正整数的重量。
>
> 早上，糕点铺已经做好了m个蛋糕。
>
> 现在，有一个顾客要来买两个蛋糕，他希望买这一天糕点铺烤好的最重的和最轻的蛋糕，并且希望这两个蛋糕的重量恰好为a和b。剩余的n-m个蛋糕可以现烤，请问小团能否满足他的要求？

```javascript
function isok(n,m,b,a,arr){


    if(a<b){
        [a,b] = [b,a];
    }

    arr = arr.sort((a,b)=>a-b);

    


    let small = arr[0];//当前最小的蛋糕
    let big = arr[arr.length-1];//当前最大的蛋糕

    if(small < b || big > a){//如果范围越界了
        return 'NO';
    }

    let cando = n-m;//表示还可以做的蛋糕数量

    if(cando >= 2 ){//如果没有越界并且可以做的蛋糕数量大于等于2，一定可以成功
        return 'YES';
    }else if(cando == 0){//如果不能再做蛋糕了

        if(m === 1){
            return 'NO';
        }else{
            if(small == b && big == a){
                return 'YES'
            }
        }

       
        return 'NO';
    }else{//cando = 1

        //接下来只存在cando = 1的情况
        if(m === 1){//蛋糕只有一个的情况

            let cake = arr[0];

            if(cake == a || cake == b){//只要重做一个
                return 'YES';
            }
            return 'NO';


        }else{//蛋糕有两个以上的情况

            if(small === b && big === a ){//如果正好符合
                return 'YES';
            }else if((small === b && big !== a) || (small !== b && big === a)){//现在做的蛋糕不符合条件
            
                return 'YES';
               
            }
            //如果两个都不符合,false

        }


    }


    return 'NO'



}

```

# 晋级人数

> 小团是某综艺节目的策划，他为某个游戏环节设计了一种晋级规则，已知在这个游戏环节中每个人最后都会得到一个分数score_i，显而易见的是，游戏很有可能出现同分的情况，小团计划该环节晋级人数为x人，则将所有人的分数从高到低排序，所有分数大于等于第x个人的分数且得分不为0的人都可以晋级。
>
> 请你求出本环节的实际晋级人数。显然这个数字可能是0，如果所有人的得分都是0，则没有人满足晋级条件。

```javascript
function getNum(x,arr){



    let sucNum = 0;//实际晋级人数

    if(x === 0){
        return 0;
    }else if(x >= arr.length){

        for(let i=0;i<arr.length;i++){

            if(arr[i] !== 0){
                sucNum++;
            }

        }
        return sucNum;
    }


    let smallArr = arr.sort((a,b)=>a-b);//从小到大排列

    let bigArr = smallArr.slice().reverse()  //从大到小排列

    console.log("small",smallArr);
    console.log("bigArr",bigArr);

    let kNum = bigArr[x-1];//第x个人的分数

   

    

    if(kNum === 0){//如果第x个人的分数为0,则判断它前面的人分数是不是0

        for(let i=0;i<x;i++){

            if(bigArr[i] !== 0){
                sucNum++;
            }
        }
        return sucNum;
    }else{//x前面的人都大于0,判断是否有和x分数一样的人

        sucNum += x;

        let index = smallArr.findIndex(item => item === kNum);//找到
        // console.log("和x分数一样的人的最大index",index);
        sucNum = sucNum + (arr.length-x-index);
        
        return sucNum;
    }



}
```

# 数组不可变(前缀和)

> 给定一个整数数组  nums，处理以下类型的多个查询:
>
> 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
> 实现 NumArray 类：
>
> NumArray(int[] nums) 使用数组 nums 初始化对象
> int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )

前缀和的思路:创建一个新的数组`preNums`,它的第i项为原数组`nums`的前i-1项和;

注意:为了方便计算，`preNums`的第一项应该为0

```javascript
var NumArray = function(nums) {


    this.preNums = new Array(nums.length+1).fill(0);

    for(let i=1;i<this.preNums.length;i++){
        this.preNums[i] = nums[i-1] + this.preNums[i-1];
    }
};

/** 
 * @param {number} left 
 * @param {number} right
 * @return {number}
 */
NumArray.prototype.sumRange = function(left, right) {

    return this.preNums[right+1] - this.preNums[left];

};
```

# 和为k的数组(前缀和)

[和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

思路:将数组的每一项的前缀和都存入map中,遇到相同的前缀和,则对应map中的key的value+1，判断是否存在value1-value2 = k,如果存在,res+1;

```javascript
var subarraySum = function(nums, k) {

    let res = 0;
    
    let map = new Map();
    map.set(0,1);

    let nums_i = 0;

    for(let i=1;i<=nums.length;i++){

        nums_i = nums[i-1] + nums_i;//获取数组前i-1项之和

        let nums_j = nums_i - k; //获取目标前缀和(nums_i-nums_j = k说明[j,i-1]这个区间符合要求)
        if(map.has(nums_j)){//判断目标前缀和是否存在
            //如果存在,则res+1；
            res += map.get(nums_j);
        }
        map.set(nums_i,(map.has(nums_i) ? map.get(nums_i) : 0) + 1);//将当前前缀和推入map中并+1；
    }

    return res;


};
```

# 二位区域和检索(前缀和)

[二维区域和检索 - 矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/)

给定一个二维矩阵 matrix，以下类型的多个请求：

计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。
实现 NumMatrix 类：

NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。


![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204111454703.png)

思路:用一个二维数组存储每一行的前缀和，计算矩阵和时分别计算矩阵每一行的前缀和，最后再加起来即可

```javascript
var NumMatrix = function(matrix) {

    this.preArr = [];

    for(let i=0;i<matrix.length;i++){
        
        let preNums = new Array(matrix[0].length+1).fill(0);

        for(let j=1;j<=matrix[0].length;j++){//获取每一行的前缀和
            preNums[j] = matrix[i][j-1] + preNums[j-1];
        }

        this.preArr.push(preNums);
    }



};

NumMatrix.prototype.sumRegion = function(row1, col1, row2, col2) {

    let sum = 0;

    for(let i=row1;i<=row2;i++){
        sum  = sum +(this.preArr[i][col2+1] - this.preArr[i][col1])
    }
    return sum;

};
```

# 二进制中1的个数

[二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 [汉明重量](http://en.wikipedia.org/wiki/Hamming_weight)).）。

思路:使用无符号右移符`>>>`和`&`符来判断,如果`n&1==0`,说明n的最后一位的值为0，否则为1

```javascript
var hammingWeight = function(n) {
   
    let res = 0;

    while(n>0){
        res += n & 1
        n = n>>>1;
    }
    return res;
};
```

# 和为s的连续正数序列

[和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

> 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
>
> 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
>

思路:使用滑动窗口,当left到right这个区间和>target，left++,当left到right这个区间和<target，right++,当left到right这个区间和=target，获得一个结果,然后让left+1，right+1，继续遍历

```javascript
var findContinuousSequence = function(target) {

    let left = 1;
    let right = 2;

    let res = [];

    while(right <= target){

        let sum = 0;

        for(let i=left;i<=right;i++){
            sum += i;
        }

        if(sum > target){
            left++;
        }else if(sum < target){
            right++;
        }else if(sum == target){//sum等于目标值

            let arr = [];
            for(let j=left;j<=right;j++){
                arr.push(j)
            }

            if(arr.length >= 2)  res.push(arr);
           

            left++;
            right++;

        }


    }

    return res;
};
```



# 小明的等差数

题目来源:京东2022暑期实习前端笔试4.16

题目描述:定义一个正整数的第i为d(i),如果这个数字的每一位都满足d(i)-d(i-1) = d(i-1)-d(i-2)....,那么就称这个数为等差数,特别的100以内的都是等差数.例如1111,4321,1234都是等差数.给定一个数字x,请求得大于等于x的最小等差数

思路:假设这个数的位数为n,那么含有n位的数的最大值(例如n=3，最大值则为999)一定是一个等差数,所以不需要考虑加位的情况,我们可以设需要求的等差数的最高位为传入的数字的最高位,且这个数每位的位差都满足[-9,9]这个区间内,所以只需要遍历[-9,9]这个区间寻找符合条件的等差数即可,不符合条件的情况是：

1.数字的某一位小于0或者大于9,

2.这个数小于传入的数字

不符合条件就应该退出遍历让首位+1，重新遍历

如果在这个区间内没有找到等差数,则让最高位+1，再次遍历,在遍历到最大值(例如n=3，最大值则为999)之前,一定能找到符合条件的等差数

```javascript
function getNum(num){//传入一个字符串

    if(parseInt(num) < 100){
        return num;
    }

   let str = num[0];//让等差数的最高位与传入数字的最高位相等
   let digit = num.length;
   

    while(1){//while不设终止条件，因为我们可以肯定一定能找到符合条件的等差数
        for(let i=-9;i<=9;i++){

            while(str.length < digit){
    
                if(parseInt(str[str.length-1]) + i < 0 || parseInt(str[str.length-1]) + i > 9){//不符合条件 直接退出
                    break;
                }
                str = str + (parseInt(str[str.length-1]) + i);//在字符串后加一位
    
            }
    
            if(parseInt(str) >= parseInt(num)){//如果找到了符合条件的等差数,直接返回
                return str;
            }
    
       
            str = str[0];//此时的i不符合条件，重置str，进行下一次遍历
    
            
            
        }
        
        str = (parseInt(str[0]) + 1).toString();//如果经过一轮遍历后都不符合,那么最高位+1重新遍历

    }
    

}
```



# 二叉树的最近公共祖先

[二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

![image-20220417210803601](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204172108699.png)

思路:递归

一个节点是公共祖先,只有以下几种情况:

- 节点的左右子树中存在p和q
- 节点本身为p或q，且p或q存在于节点的左子树
- 节点本身为p或q，且p或q存在于节点的右子树

```javascript
var lowestCommonAncestor = function(root, p, q) {
    
    //如果当前节点为p或者q或者null,则直接返回该节点
    if(root == null || root == p || root == q ){
        return root;
    }

    //获取当前节点的左子树中为p或者为q或者为null的节点
    let left = lowestCommonAncestor(root.left,p,q);
    //获取当前节点的右子树中为p或者为q或者为null的节点
    let right = lowestCommonAncestor(root.right,p,q);

    //如果当前节点的左子树为空,那么两个目标节点一定存在于右子树中
    if(left == null) return right;
    //如果当前右子树为空,那么目标节点一定存在于左子树中
    if(right == null) return left;

    //现在左右子树都不为空,那么当前节点root就是最近公共祖先
    return root;

};
```

# 1+2+...+n

[求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

![image-20220419204126562](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204192041626.png)

思路:递归 + 逻辑与(&&)终止递归

```javascript
var sumNums = function(n) {

    let res = 0;//res作为全局变量
    function deep(n){

        let x = n >1 && deep(n-1);//只要n不小于1就会一直递归 然后res加上n，最后返回res就可以了

        res += n;

        return res;

    }
    return deep(n);

};


```



# 栈的压入、弹出序列

[栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
>

思路:新建一个辅助栈,顺序压入压栈序列的每一个元素,当遇到栈顶元素等于出栈序列的当前元素时,辅助栈出栈,最后判断辅助栈是否为空即可判断答案

```javascript
var validateStackSequences = function(pushed, popped) {

    let arr = [];
    let i=0;
    for(let item of pushed){
        arr.push(item);

        while(arr.length && popped[i] == arr[arr.length-1]){
            arr.pop();
            i++;
        }

    }

    return !arr.length 

};
```

# 丑数

[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

> 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

思路:我们需要明白一点,假如一个数是a丑数,那么a×2、a×3、a×5肯定也都是丑数,我们寻找第n个丑数,实际上就是**寻找前n个丑数中`乘以二`或者`乘以三`或者`乘以五`,满足新的数值大于第n-1个丑数的`最小值`**,我们可以利用动态规划完成这个题

![image-20220426212107564](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204262121651.png)

```javascript
var nthUglyNumber = function(n) {

    let dp = new Array(n).fill(0);

    let a = 0,b = 0,c = 0;//设置指针初始都指向0

    dp[0] = 1;//1是丑数

    for(let i=1;i<n;i++){

        let n2 = dp[a]*2,n3 = dp[b]*3,n5=dp[c]*5;

        dp[i] = Math.min(dp[a]*2,dp[b]*3,dp[c]*5);//获取满足条件的最小丑数

        if(dp[i] == n2){//如果新的丑数是由dp[a]*2得来的,那么dp[a]将不满足未来的丑数递推公式,a指针应该右移
            a++;
        }

        if(dp[i] == n3){//如果新的丑数是由dp[b]*3得来的,那么dp[b]将不满足未来的丑数递推公式,b指针应该右移
            b++;
        }

        if(dp[i] == n5){//如果新的丑数是由dp[c]*5得来的,那么dp[c]将不满足未来的丑数递推公式,c指针应该右移
            c++;
        }
    }

    return dp[n-1];



};
```

# 字符串的排列

[字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

> 输入一个字符串，打印出该字符串中字符的所有排列。
>
> 
>
> 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

## 1.递归遍历

思路:递归遍历每一种排列,然后用set去重

```javascript
var permutation = function(s) {

    let res = [];
    if(s.length == 1 ) {
        return [s]
    }else{

        for(let i=0;i<s.length;i++){

            let basis = s[i];
            let left = s.slice(0,i);
            let right = s.slice(i+1,s.length);

            let strArr= permutation(left+right);

            for(let j=0;j<strArr.length;j++){

                res.push(basis+strArr[j]);

            }

        }

    } 




    return [...new Set(res)];
};
```

## 2.回溯法

思路:遍历字符串,固定第x位,将x位之后的交换顺序,当数组长度等于字符串时,压入res中,放字符串存在重复字母时会出现组合重复的问题,要利用剪枝将其去掉

根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 11 位字符（ nn 种情况）、再固定第 22 位字符（ n-1n−1 种情况）、... 、最后固定第 nn 位字符（ 11 种情况）。

![Picture2.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204291858129.png)

```javascript
var permutation = function(s) {

    let res = [];
    
    function dfs(x,str){
        if(x == s.length-1){
          return   res.push(str.join(''));
        }
        let set = new Set();
        for(let i=x;i<str.length;i++){

            if(set.has(str[i])) continue;//如果set中存在当前字符,直接continue

            set.add(str[i]);

            [str[i],str[x]] = [str[x],str[i]];

            dfs(x+1,str.slice());

            [str[i],str[x]] = [str[x],str[i]];

        }


    }


    dfs(0,s.split(''));

    return res;

};
```



# 数字序列中某一位的数字

[数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

> 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
>
> 请写一个函数，求任意第n位对应的数字。
>

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204291744932.png)



 思路:找规律,如上图,我们根据start和digit就能求出数位数量,从而找到n属于哪一个数字的元素,再根据余数获取n在数字中的位置

![Picture2.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204291748923.png)

```javascript
var findNthDigit = function(n) {

   if(n<10){
        return n;
    }

	//初始值
    let start = 1;
    let digit = 1;
    let num =  10;
    
    while(n >= num){//获取n位所在的数字范围

        n -= num;
        start *= 10;
        digit += 1;
        num = 9*start*digit;
    
    }

    let count = start + parseInt(n / digit) ;//count代表n位所在的数字
    let yu = n % digit;//获取余数,这表示n在count中的位置

   let count1 = count.toString()
   return count1[yu];//根据位置获取具体数值



};
```



# 圆圈中最后剩下的数字(约瑟夫环问题)

[圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

> 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
>
> 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
>

实际上就是约瑟夫环问题,问题描述是

> N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。

思路:动态规划,当只剩一个人的时候,那么不管M是多少,被杀的的一定是这个人(假设最后一个人也杀掉),换个说法就是,当只剩一个数字时,不管m是多少,最终一定指向这个数字(他的下标为0),所以我们可以直到最后一个数字的下标一定为0,我们反推,就可以获得递推公式

![image-20220502192130703](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202205021921791.png)

![image-20220502192145214](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202205021921380.png)

说通俗点就是,n=7时,序列为`DEFGHAB`,那么我补上被杀掉的`C`,再让序列右移m,再%n,这样就能获得n=8时的序列,而最终值的下标的递推也是如此,序列变了,下标也肯定会跟着变,根据递推公式我们就能求得n为任意值时,最终数的下标

不需要用dp数组实现,代码实现非常简单

```javascript
var lastRemaining = function(n, m) {

    let res = 0;

    for(let i=1;i<=n;i++){

        res = (res+m) % i;

    }
    return res;

};
```

# n个骰子的点数

[n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

> 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。
>
>  
>
> 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
>

思路:动态规划 ,递推公式如下,n为骰子数量,x为n个骰子的点数和

假设已知 n - 1 个骰子的解 f(n - 1) ，此时添加一枚骰子，求 n 个骰子的点数和为 x 的概率 f(n, x)。

当添加骰子的点数为 1 时，前 n - 1 个骰子的点数和应为 x - 1 ，方可组成点数和 x ；同理，当此骰子为 2 时，前 n - 1 个骰子应为 x - 2 ；以此类推，直至此骰子点数为 6 。将这 6 种情况的概率相加，即可得到概率 f(n, x)

![image-20220508190022398](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202205081900441.png)

```javascript
var dicesProbability = function(n) {
	
    //当骰子数量为n时,点数和的范围为[n,n*6]
    
    let res = [];
    let dp = new Array(n+1).fill(0).map((item)=> new Array(6*n+1).fill(0));



    for(let i=1;i<=6;i++){
        dp[1][i] = parseFloat(1/6);//当只有一个骰子时,每一个点数的概率都为1/6
    }

	
    for(let i=2;i<=n;i++){

        for(let j=i;j<=i*6;j++){

            for(let k=1;k<=6;k++){

                if(j-k > 0){
                    dp[i][j] += parseFloat(dp[i-1][j-k]/6) 
                }else{
                    break;
                }
            }
        }

    }

    for(let i=n;i<=6*n;i++){
        res.push(dp[n][i]);
    }

    return res;

};
```

# 重建二叉树

> 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
>
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202205202047043.jpeg)

思路:以上图为例,前序遍历的结果是3、9、20、15、7,中序遍历的结果是9、3、15、20、7，根据前序遍历我们可以推出根节点的值是3(根左右)，而中序遍历的顺序是`左根右`,所以我们根据前序遍历推出的根节点的值再结合中序遍历数组就可以推出树的左子树的中序遍历是[9],前序遍历是[9],右子树的中序遍历是[15,20,7],前序遍历是[20,15,7],然后利用递归即可求出树的根节点

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202205202052808.png)

```javascript
var buildTree = function(preorder, inorder) {

    if (!preorder.length || !inorder.length) {
        return null;
    }

    let root = preorder[0];
    let node = new TreeNode(root);



    let childPreRight = [];//前序遍历结果
    let childPreLeft = [];

    let childInRight = [];//中序遍历结果
    let childInLeft = [];

    let rootIndex = inorder.findIndex(item => item === root)
    
    childPreLeft = preorder.slice(1,rootIndex+1)
    childInLeft = inorder.slice(0,rootIndex)

    

    
    childPreRight = preorder.slice(rootIndex+1)
    childInRight = inorder.slice(rootIndex+1)

    node.left = buildTree(childPreLeft,childInLeft)
    node.right = buildTree(childPreRight,childInRight)
    
    return node;

};
```

# 机器人的运动范围

[机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

> 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
>
> 

思路:dfs,不用多言

```javascript
let board ;
var movingCount = function(m, n, k) {

    board = new Array(m).fill(0).map(()=>new Array(n).fill(0));

    return dfs(0,0,m,n,k);


};


function dfs(i,j,m,n,k){

    if(i>=m || j>=n || board[i][j] == 1 || getSum(i)+getSum(j) > k) return 0;

    board[i][j] = 1;

    return 1 + dfs(i+1,j,m,n,k) + dfs(i,j+1,m,n,k); 

}

function getSum(x){//获取数字的各位之和

    let sum = 0;

    while(x>0){

        sum += x % 10;
        x = parseInt(x / 10);

    }

    return sum;

}
```

# 剪绳子Ⅱ

[剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
>  
>

思路:剪绳子的题目就无脑把他剪成长度为3的绳子,如果最后剩余的绳子为1,那么把他补到最后一个长度为3的绳子上,如果为2,那么就留下来

```javascript
var cuttingRope = function(n) {

    if(n <= 2){
        return 1;
    }
    if( n === 3){
        return 2;
    }
    let res = 1;
    let chu = parseInt( n / 3);

    let yu = n % 3;

    if(yu === 0){

        for(let i=0;i<chu;i++){

            res = (res*3)%(1e9+7);

        }

        return res;

    }else if(yu === 1){

        for(let i=0;i<chu-1;i++){

            res = (res*3)%(1e9+7);

        }

        return (res * 4) % (1e9 + 7)
    }else{

        for(let i=0;i<chu;i++){

            res = (res*3)%(1e9+7);

        }

        return (res * 2) % (1e9 + 7)
    }


};
```

