## 

# 比特位计数

## 题目描述

给定一个非负整数 **num**。对于 **0 ≤ i ≤ num** 范围中的每个数字 **i** ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例1:

> ```
> 输入: 2
> 输出: [0,1,1]
> ```

示例2:

> ```
> 输入: 5
> 输出: [0,1,1,2,1,2]
> ```

进阶:

- 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？


- 要求算法的空间复杂度为**O(n)**。

- 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 **__builtin_popcount**）来执行此操作

## 题目来源:

> ```
> 剑指offer(专项突击版) [剑指offer|| 003]前n个数字二进制中1的个数
> ```

[力扣 338.比特币计数]: https://leetcode-cn.com/problems/counting-bits/

## 题解

> 为了表述简洁，下文用「一比特数」表示二进制表示中的 1 的数目。

### 解法一 暴力枚举

> 这是我最先想到的方法,两个循环暴力枚举直接出结果，但是这种方法的时间复杂度和空间复杂度都很高.
>
> 定义一个数组，将0~n进行遍历，将循环中的i转换成二进制字符串，然后将二进制字符串分割成数组chars，再对chars进行遍历，如果chars[j]=‘1’,sum++;遍历完之后将sum添加到数组中.



```javascript
var countBits = function(n) {

    let sum = 0;
    let number = [];
    for(let i=0;i<=n;i++ ){
        let value = i.toString(2);
        let chars = value.split('');
        for(let j=0;j<chars.length;j++){
            if(chars[j] == '1')
                sum++;
        }
        number.push(sum);
        sum=0;
    }
    return number

 }
```

### 解法二  Brian Kernighan算法位运算

> 位运算&表示**同1为1**, 令**x&(x-1)**,该运算将x的二进制表示的最后一个1变成0，因此，对 *x* 重复该操作，直到x变成0,则操作次数即为x的「一比特数],例如：令x=10，二进制表示位1010,(x-1)=9.二进制表示为1001,10&9=1000. 1000比1010少了一个1
>
> 对于给定的 n，计算从 0 到 n 的每个整数的「一比特数」的时间都不会超过 )O(logn)，因此总时间复杂度为 O(nlogn)。

```javascript
var countBits = function(n) {
	   const  bits = new Array(n+1).fill(0)
    for(let i=0;i<=n;i++){
        let num = getNumOne(i);
        bits[i] = num;
    }
    return bits;
 }
var getNumOne = function (n){
    let x=0
    while(n>0){
        n&=(n-1);//n&(n-1) = (n-1)
        x++;
    }
    return x
}
```

**时间复杂度**:O(nlogn)。需要对从0到n的每个整数使用计算「一比特数」，对于每个整数计算							「一比特数」的时间都不会超过O(logn)。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法三 动态规划 位运算(最高有效位)

> 当计算 i 的「一比特数」时，如果存在 0 <=j<i，j 的「一比特数」已知，且 i 和 j 相比，i的二进制表示只多了一个 1，则可以快速得到 i 的「一比特数」。
>
> 上述关系可以表示成: **bits[i]=bits[j]+1**
>
> 对于正整数x，如果可以知道最大的整数y,使得y<=x并且y是2的整数次幂，则y的二进制表示中只有最高位是1，其余都是0，此时称 *y* 为 *x* 的「最高有效位」。**令z=x-y,则bits[x]=bits[z]+bits[y]=bits[z]+1**
>
> 为了判断一个正整数是不是 2 的整数次幂，可以利用方法二中提到的按位与运算的性质,如果y是2的整数次幂,则y&(y-1)=0;由此可见没正整数y是2的正整数次幂，当且仅当y&(y-1)=0
>
> 如果i&(i-1)=0,则令hignBit=i,更新当前的最高有效位
>
> **bits[i]=bits[i-hignBit]+1**
>
> 

```javascript
   const  bits = new Array(n+1).fill(0);
    let hignNum=0;
    for(let i=1;i<=n;i++){
        if((i&(i-1))==0){
            hignNum = i;
        }
        bits[i] = bits[i-hignNum]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法四 动态规划 位运算(设置最低位)

> 定义正整数 x 的「**最低设置位**」为 *x* 的二进制表示中的最低的 1 所在位，例如，10的二进制表示是1010，其最低设置位是2，二进制表示为10
>
> 令y=x&(x-1),则y为将x的最低设置位从1变成0之后的数，显然0<=y<=x,bits[x]=bits[y]+1,
>
> 对于任意正整数x，都有bits[x]=bits[x&(x-1)]+1

```javascript
 const  bits = new Array(n+1).fill(0)
    for(let i=1;i<=n;i++){
        bits[i]=bits[(i&(i-1))]+1;
    }
    return bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

### 解法五 动态规划 位运算(最低有效位)

> 对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是[x/2],如果bits[x/2]已知，则可以得到bits[x]的值
>
> - 如果 x 是偶数，bits[x]=bits[x>>1]
>
> - 如果 x 是奇数，bits[x]=bits[x>>1]+1
>
> 判断x的奇偶可以通过x&1得到，如果为奇数，x&1=1，反之为0
>
> 则 bits[x]=**bits[x>>1]+(x&1)**



```javascript
    const bits = new Array(n+1).fill(0);
    for(let i = 1;i<=n;i++){
        bits[i] = bits[i>>1]+(i&1)
    }
    return  bits;
```

**时间复杂度**:O(n)。对于每个整数，只需要 O(1) 的时间计算「一比特数」。

**空间复杂度**:O(1)。除了返回的数组以外，空间复杂度为常数。

# 二进制加法

## 1.题目描述

```
给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。
```

```
示例 1:
输入: a = "11", b = "10"
输出: "101"
示例 2:
输入: a = "1010", b = "1011"
输出: "10101"
提示：
每个字符串仅由字符 '0' 或 '1' 组成。
1 <= a.length, b.length <= 10^4
字符串如果不是 "0" ，就都不含前导零。
```

## 2.题目来源

> 剑指offer(专项突击版) [剑指offer|| 002]二进制加法

[力扣官网](https://leetcode-cn.com/problems/add-binary/)

## 3.题解

**解答这道题的问题是两个数的加法运算是从低位到高位的,我们要将字符串从后往前遍历，最后求得的结果再翻转**

**另外我们还要考虑两个字符串长度不一样的情况，遍历时我们需要判断字符串是否遍历完成，这样才能获取正确结果**

下方代码中，**ans**表示**结果字符串**，**ca**表示进**位的值**，**sum**表示**当前遍历位的值**，**如果sum>=2,我们需要往后进一位，遍历到下一个值时，我们需要让sum加上遍历上一个值是所进的位数值**

```javascript
var addBinary = function(a, b) {
    let ans =''
    let ca = 0
    for(let i =a.length-1,j=b.length-1;i>=0||j>=0;i--,j--){
        let sum = ca
        sum += i>=0 ? parseInt(a[i]) : 0//如果a遍历完成了,sum不再加a[i]
        sum += j>=0 ? parseInt(b[j]) : 0//如果b遍历完成了,sum不再加b[i]
        ans += sum % 2 //将当前位的值加入到ans中，如果sum=2，则当前位为0
        ca = Math.floor(sum / 2)//向下取整sum/2,如果sum=2，则进位加1
    }
    ans += ca>0? 1 : ''//最后判断进位的值，如果ca>0，结果应该加进位1，否则不变
    return ans.split('').reverse().join('')//最后将字符串进行反转求得结果
};
```

# 移除K位数字

## 1.题目描述

**给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。**

> 示例 1 ：
>
> 输入：num = "1432219", k = 3
> 输出："1219"
> 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
> 示例 2 ：
>
> 输入：num = "10200", k = 1
> 输出："200"
> 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
> 示例 3 ：
>
> 输入：num = "10", k = 2
> 输出："0"
> 解释：从原数字移除所有的数字，剩余为空就是 0 。
>
>
> 提示：
>
> 1 <= k <= num.length <= 105
> num 仅由若干位数字（0 - 9）组成
> 除了 0 本身之外，num 不含任何前导零

## 2.题目来源

[力扣官网](https://leetcode-cn.com/problems/remove-k-digits/)

## 3.题解(JavaScript)

我们要求得移除k位数的最小数字，可以使用单调栈来解答

假设有两个长度相等的数 a=12345678 b=15345678

判断这两个数的大小就是看它们从高位至低位第一个不同数字的大小

例如5>2，故b>a

我们解答这个题目，需要从左至右遍历字符串，保证栈中的元素是单调递增的

**如果当前遍历的数字大于或者等于栈顶数字 入栈**

**如果当前遍历的数字小于栈顶数字 将栈顶数字出栈**

```javascript
var removeKdigits = function(num, k) {
    //如果k大于或者等于字符串的长度，说明字符串可以全部移除，返回'0'
    if(num.length <= k)
    return '0'
    const stk = []
    let ans = ''
    //遍历num
    for(const ch of num){
        //如果遍历的数字小于栈顶元素，栈顶元素出栈，k-1
        while(k&&ch<stk[stk.length-1]&&stk.length){
            stk.pop()
            k--
        }
        stk.push(ch)
    }
    //如果遍历完之后k仍大于0，我们从栈中移除相应数量的数字
    while(k--){
        stk.pop()
    }
    let flag = 0
    //如果有前置0，则不输出前置0
    for(let i=0;i<stk.length;i++){
        if(stk[i]!=0){
            flag=1
        }
        if(flag===1){
            ans+=stk[i]
        }

    }
    return ans===''?'0':ans
};
```

# 有效的括号

## 1.题目描述

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
```

> ```
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 
> 示例 1：
> 
> 输入：s = "()"
> 输出：true
> 
> 示例 2：
> 
> 输入：s = "()[]{}"
> 输出：true
> 
> 示例 3：
> 
> 输入：s = "(]"
> 输出：false
> 
> 示例 4：
> 
> 输入：s = "([)]"
> 输出：false
> 
> 示例 5：
> 输入：s = "{[]}"
> 输出：true
> 
> 提示：
> 
> 1 <= s.length <= 104
> s 仅由括号 '()[]{}' 组成
> 
> ```

## 2.题目来源



[力扣官网](https://leetcode-cn.com/problems/valid-parentheses/)

## 3.题解(使用JavaScript作为编程语言)

解答这个题最好的方法就是栈，我们可以**利用栈的后进先出的特点，依次对比每个括号的有效性**

另外，我们可以**将三种括号作为key和value存入哈希表**中，用来查值

```javascript
var isValid = function(s) {
    if(s.length%2!=0)
        return false
    const stk = []
    //创建map表，右括号作为key，左括号作为value
    const  map = new Map([
        [')','('],
        ['}','{'],
        [']','['],
    ])
    //遍历s
    for(let ch of s){
        
        if(map.has(ch)){
            //如果map存在key的值为ch，并且栈顶元素的值与map对应key的value一样，如果这个括号合法，否则不合法直接return false
            if(!stk.length || stk[stk.length-1] != map.get(ch)){
                return  false
            }
            stk.pop()
        }else{
            //如果map中不存在key的值为ch，则说明此时遍历的是左括号，直接入栈
            stk.push(ch)
        }
    }
    //最后判断栈中元素是否为空，如果为空说明括号都已经匹配成功，返回true
    return stk.length?false:true
}
```

# 整数除法

## 题目描述

给定两个整数 **a** 和 **b** ，求它们的除法的商 **a/b** ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。

示例1:

> ```
> 输入：a = 15, b = 2
> 输出：7
> 解释：15/2 = truncate(7.5) = 7
> ```

示例2:

> ```
> 输入：a = 7, b = -3
> 输出：0
> 解释：7/-3 = truncate(-2.33333..) = -2
> ```

示例3:

> ```
> 输入：a = 0, b = 1
> 输出：0
> ```

示例4:

> ```
> 输入：a = 1, b = 1
> 输出：1
> ```

**提示**:-2^31<=a,b<=2^31-1,b!=0



## 题目来源:

> 剑指offer(专项突击版) [剑指offer|| 001]整数除法
>
> ```
> https://leetcode-cn.com/problems/divide-two-integers/
> ```

## 题解

> 设sum为a除以b的商,a和b的范围是-2^31~2^31,如果按照{a=a-b,sum++},当且仅当a>=b的思路时间复杂度太高，肯定会超时,所以我们应该时循环的次数变得尽可能的少。
>
> 我们可以让b1=b,task=1，累加(b1+b1),直到**b1+b1>a**,此时的b已经是a的**最大可除数**，记录b1累加的次数task，此时b1=task*b，再将a-b1,可以将a拆分成更小的数，将task重置为1,b1=b,继续执行上述操作，最终可以求出a除以b的商
>
> 设test =b,task=1,sum=0,重复执行此操作:b每次累加(b=b+b),task也累加(task=task+task),a=a-test,sum=sum+task,直到a<=test+test,操作结束.再对a和b的大小进行判断，如果此时a<b,则返回sum，如果a=b,返回sum+1
>
> 上述关系可以表示成:**(a-task1×b-task2×b-...taskn×b)/b+task1+task2+...taskn**
>
> 例如:a=60,b=13,a/b=(60-52)/13+4,sum=4.a=70,b=12,a/b=(70-48-12)/12+4+1
>
> 

```javascript
var divide = function(a, b) {
    let num = a
    let sum = 0
    if(a>=0&&b>0){
        if(a>=Math.pow(2,31)-1&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(a>test+test){
                test+=test
                task+=task
            }
            a-=test
            sum+=task
            }
    }else if(a<=0&&b<0){
        if(a<=-Math.pow(2,31)&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = -b
            let task = 1
            if(-a<-b){
                return sum
            }
            if(a==b){
                return sum+1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a>=0&&b<0){
        if(a>=Math.pow(2,31)-1&&b==-1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1
            if(a<-b){
                return -sum
            }
            if(a==-b){
                return -sum-1
            }
            while(a>Math.abs(test+test)){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }else if(a<=0&&b>0){
        if(a<-Math.pow(2,31)&&b==1){
            return Math.pow(2,31)-1
        }
        for(let i=1;i;i++){
            let test = b
            let task = 1

            if(-a<b){
                return -sum
            }
            if(-a==b){
                return -sum-1
            }
            while(-a>test+test){
                test+=test
                task+=task
            }
            a+=test
            sum+=task
        }
    }

};
```

# 最长有效括号

## 1.题目描述

```
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
```

```
示例 1：
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：
输入：s = ""
输出：0
提示：
0 <= s.length <= 3 * 104
s[i] 为 '(' 或 ')'
```

## 2.题目来源

## 3.题解

解决这道题，我们可以用栈来存取字符串的下标来判断最长有效长度

为了计算有效长度，我们需要在初始时在栈中push -1，因为当计算有有效长度时，如果一对括号的下标分别为0和1，那么求出的有效长度为1-0=1，不符合正确有效长度

如果遍历的字符为左括号，我们将字符的下标入栈

如果遍历的字符为右括号，我们让栈顶元素出栈:

​	1.如果此时栈为空，说明栈中没有含有值为左括号的字符的下标，我们将当前字符下标入栈，用于重置			有效下标

​	2.如果此时栈不为空，我们判断maxlength和i-stack[stack.length-1] （当前计算出来的有效长度）的大			小，并重新赋值

最后返回**maxlength**的值

```javascript
var longestValidParentheses = function(s) {
    const stack = []
    stack.push(-1)//在初始时推入-1
    let maxlength=0
    for(let i = 0 ; i < s.length ; i++){
        if(s[i]==='('){
            stack.push(i)//如果遍历的字符为'('，将其下标入栈
        }else{
            //栈顶元素出栈，用于判断栈中是否含有有效括号的下标
            stack.pop()
            if(!stack.length){
                //如果此时栈为空，则将i入栈，用于重置有效下标
                stack.push(i)
            }else{
                //如果栈不为空，计算maxlength的值
                maxlength = maxlength > (i-stack[stack.length-1]) ? maxlength : (i-stack[stack.length-1])
            }
        }

    }
    return maxlength
}
```

# 随机选取数组元素的时候避免相邻重复

迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换，这个随机位置比当前位置小。这个算法可以保证随机过的位置不会再被随机一次。

```javascript
const swap = (arr,i,j) => { [arr[i],arr[j]] = [arr[j],arr[i]] } //交换数组中的两个位置

function getrandom(arr){

    for (let i = arr.length-1; i >= 0 ; i--) {
        //Math.random随机范围为[0,1),Math.floor向下取整    
        const randomIndex = Math.floor( Math.random()*i)
        console.log(arr[randomIndex]);
         //随机过的位置放后面
        swap(arr,i,randomIndex)
    }
}
const arr = [1,2,3,4,5,6,7,8,9,10]
getrandom(arr)
```

# 二叉树遍历

## 前序遍历

递归法

```javascript
var preorderTraversal = function(root) {
     let res = []
     let a = function (root){
         if(!root)
             return
         res.push(root.val)
         a(root.left)
         a(root.right)
     }
     a(root)
     return  res

};
```

回溯法

```javascript
var preorderTraversal = function(root) {

    let res =[]
    let stk= []
    while(root||stk.length){
        while(root){
            res.push(root.val)
            stk.push(root)
            root = root.left
        }
        root = stk.pop()
        root = root.right
    }
    return res

};
```



## 中序遍历

递归法

```javascript
var inorderTraversal = function(root) {

    let res = [];
    function a(root){
        if(!root) return;
        a(root.left);
        res.push(root.val);
        a(root.right);
    }
    a(root);
    return res;
}
```

回溯法

```javascript
var inorderTraversal = function(root) {

  let res = [];
  let stk = [];
  while(root || stk.length){

      while(root){
          stk.push(root);
          root = root.left;
      }
      root = stk.pop();  
      res.push(root.val);
      root = root.right;
  }
  return res;
}
```



## 后序遍历

递归法

```javascript

var postorderTraversal = function(root) {
     let res = []
     let a=function (root){
        if(!root)
             return
         a(root.left)
         a(root.right)
         res.push(root.val)
     }
     a(root)
     return  res
};
```

回溯法

```javascript
var postorderTraversal = function(root) {
    let res = [];
    let stk = [];
    while(root || stk.length){
        while(root){
            res.push(root.val);
            stk.push(root);
            root = root.right;

        }
        root = stk.pop();
        root = root.left;
        
    }
    let reserveRes = res.reverse()//将中右左翻转为左右中
    return res;
};
```



# 二叉树的最大深度

leetcode(104)

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。

```javascript
var maxDepth = function(root) {
    let max = 0;
    let a = function(root,dept){
        if(!root){
            max = dept > max ? dept : max;
            return;
        }else{
            dept++;
        }
        a(root.left,dept);
        a(root.right,dept);
    }
    a(root,0);
    return max;
};
```

# 相同的树

> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```javascript
var isSameTree = function(p, q) {
    
    let flag = true;
    function isSame(ptree,qtree){

        if(!ptree && !qtree) return;
        if((!ptree && qtree) || (ptree && !qtree)){
            flag = false;
            return;
        } 
        if(ptree.val !== qtree.val){
            flag = false;
            return;
        } 

        isSame(ptree.left,qtree.left);
        isSame(ptree.right,qtree.right);
    
    }
    isSame(p,q);
    return flag;

};
```

# 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**思路**:把根节点左节点作为左树，右节点作为右树,将左树的左节点与右树的右节点对比,左树的右节点与右树的左节点对比,最后返回结果

```javascript
var isSymmetric = function(root) {

   function compareRoot(leftNode,rightNode){
       if(!leftNode && rightNode){
           return false;
       }else if (leftNode && !rightNode){
           return false;
       }else if(leftNode === null && rightNode === null){
           return true;
       }
       else if(leftNode.val !== rightNode.val){
           return false;
       }

        return compareRoot(leftNode.left,rightNode.right) && compareRoot(leftNode.right,rightNode.left)
   }

    if(!root) return true
   return compareRoot(root.left,root.right);


};
```

# 二叉树的最小深度

[ 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。

```javascript
var minDepth = function(root) {

    let min = 10001;
    if(!root){
        return 0;
    }else if(root.left === null && root.right !==null){
        getMin(root.right,1);
    }else if(root.right !== null && root.right === null){
        getMin(root.left,1);
    }else if(root.left === null && root.right === null){
        return 1;
    }else{
        getMin(root,0);
    }

    function getMin(node,dept){
        dept++;
        if(node.left === null && node.right === null){
            min = min < dept ? min : dept;
            return;
        }else if(node.left!==null && node.right === null){
            getMin(node.left,dept);
        }else if(node.left === null && node.right !== null){
            getMin(node.right,dept);
        }else if(node.left !==null && node.right !== null){ 
            getMin(node.left,dept);
            getMin(node.right,dept);
        }
      
    }
    // getMin(root,0);
    return min;

};
```

# 二叉树大的层序遍历

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

**思路**：通过一个 while 循环控制从上向下一层层遍历，for 循环控制每一层从左向右遍历：用一个数组存储当前遍历层级的二叉树节点,另一个数组存储这层的二叉树节点的值

```javascript
var levelOrder = function(root) {

    if(!root) return [];
    let queen = [root];
    let res = [];
    while(queen.length){

        let currentLength = queen.length;
        res.push([]);

        for(let i = 0 ;i <currentLength; i++){
            
            let node = queen.shift();
            res[res.length-1].push(node.val);
            
            node.left && queen.push(node.left);
            node.right && queen.push(node.right);
        }

    }
    return res;
};
```

# 合并两个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

```javascript
var merge = function(nums1, m, nums2, n) {

    for(let i = m,j=0;i<nums1.length;i++,j++){
        nums1[i] = nums2[j];
    }
    nums1.sort((a,b)=>{
        return a-b;
    });
    
};
```

# 多树元素

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```javascript
var majorityElement = function(nums) {
   if(nums.length <= 2) return nums[0];
   nums.sort((a,b)=>{
       return a-b;
   })
   return nums[parseInt(nums.length/2)];
};
```

# 回文链表

https://leetcode-cn.com/problems/palindrome-linked-list/

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

```javascript
var isPalindrome = function(head) {
   
   let arr1 = [];
   let arr2 = [];
   while(head){
       arr1.push(head.val)
       head = head.next;
   }
   arr2 = arr1.reverse();
   for(let i =0,j=arr2.length-1;i<arr1.length,j>=0;i++,j--){
       if(arr1[i] !== arr2[j]) return false;
   }
   return true;
};
```

# 链表中倒数第K个节点

[ 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

```javascript
var getKthFromEnd = function(head, k) {
	//先遍历一遍链表获取链表的长度,然后再遍历一遍链表就ok了
    let length = 1;
    let i = 1;
    let head1 = head;
    while(head){
        head = head.next;
        length++;
    }
    while(head1){
        if(length - i === k) return head1;
        i++;
        head1 = head1.next;
    }

};
```

# 环形链表

[ 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

思路:定义快指针和慢指针,快指针一次走两步，慢指针一次走一步,如果最终快指针等于慢指针,说明快指针比慢指针多走了一圈了,存在环

```javascript
var hasCycle = function(head) {
    
    let slow = head;
    let fast = head;
    while(fast && fast.next){
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast){
            return true;
        }
    }
    return false;

};

```



# 斐波那契数列

[ 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

思路:建立一个数组,将所有的情况通过一次循环存储起来,这样子时间复杂度为O(n),如果通过递归,则需要O(2^n)

```javascript
var fib = function(n) {

    if(n === 0) return 0;
    let dp = new Array(n+1).fill(0);
    dp[1] = 1;
    for(let i = 2;i <= n;i++){
        dp[i] = (dp[i-1]  + dp[i-2]) % (1e9+7);
    }
    return dp[n] ;
   
};
```

# 最少的硬币数目

[最少的硬币数目](https://leetcode-cn.com/problems/gaM7Ch/)

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
> 你可以认为每种硬币的数量是无限的。
>

 

思路：记录每一种情况,并用数组存起来(避免递归多层造成超时)

```javascript
var coinChange = function(coins, amount) {

    let dp = new Array(amount+1).fill(amount+1);//数组初始值一定要大于amount，否则对比最小值时会出错
    dp[0] = 0;
    for(let i=1;i<dp.length;i++){
        for( let coin of coins){
            if(i - coin < 0) continue;
            dp[i] = Math.min(dp[i],dp[i-coin]+1)//这里如果数组初始值小于amount，那么dp[i]就不会变 
        }
    }
    return (dp[amount] === amount+1) ? -1 : dp[amount]

};
```

# 包含min函数的栈

[包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

思路：创建一个普通栈和一个最小栈,每当普通站push时,最小栈push当前普通栈中最小值

```javascript
var MinStack = function() {
    this.stk = [];
    this.stk_min = [Infinity];
};

/** 
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function(x) {
    this.stk_min.push(Math.min(this.stk_min[this.stk_min.length-1],x))
    this.stk.push(x);
    
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function() {
    this.stk.pop()
    this.stk_min.pop();
};  

/**
 * @return {number}
 */
MinStack.prototype.top = function() {
    return this.stk[this.stk.length-1]
};

/**
 * @return {number}
 */
MinStack.prototype.min = function() {
    return this.stk_min[this.stk_min.length-1];
};
```

# 用两个栈实现队列

[ 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
>

思路:创建一个输入栈和一个输出栈,每次插入时往输入栈中push，删除时判断输出栈是否有元素,如果没有就将输入栈中元素倒序push进输出栈中(因为队列是先进先出，栈是后进先出,栈顶元素其实是队列尾部元素,所以要倒序转换一下),然后删除栈顶元素

```javascript
var CQueue = function() {
        this.putStk = [];
        this.outStk = [];
};

/** 
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function(value) {
    this.putStk.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function() {
    
    if(!this.outStk.length){

        if(!this.putStk.length) return -1;

        while(this.putStk.length){
            this.outStk.push(this.putStk.pop())
        }
    }

    return this.outStk.pop();
};
```

# 青蛙跳台阶问题

[青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

> 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> 思路:用dp将所有状态储存起来然后输出
>

```javascript
var numWays = function(n) {
    let dp = new Array(n+1).fill(-10);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    for(let i=3;i<=n;i++){
        
        dp[i] = (dp[i-1]+dp[i-2])%(1e9+7);


    }
    return dp[n]
};
```



# 反转链表

[反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

迭代法

思路:用一个变量存放当前节点的后一个节点,然后将当前节点的next指向它的前一个节点

```javascript
var reverseList = function(head) {
    let pre =null;
    let curr = head;
    while(curr){
        let next = curr.next;
        curr.next = pre;
        pre = curr;
        curr = next;
    }
    return pre;
};
```

递归

思路:

```javascript
var reverseList = function(head) {
    
    function  reverse(head){
        
        if(head === null || head.next === null){//如果遍历到了末尾节点
            return head;
        }
        let last = reverse(head.next);

        head.next.next = head;
        head.next = null;

        return last;
    }

    return reverse(head);
};
```

# 反转链表Ⅱ

[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

> 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
> 
>

```javascript
var reverseBetween = function(head, left, right) {

    if(left === 1){
        return reverse(head,right);
    }

    head.next = reverseBetween(head.next,left-1,right-1);//将反转链表的前一个节点与反转链表拼接

    return head;


    

};
let success = null;
function reverse(head,n){

    if(n === 1){
        success = head.next;//获取反转链表的后一个节点
        return head;
    }

    let last = reverse(head.next,n-1);
    head.next.next = head;
    head.next = success;

    return last;
}
```

# 替换空格

[替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

思路:双指针

```javascript
var replaceSpace = function(s) {

    let arr = Array.from(s);
    let count = 0;
    
    for(let i=0;i<arr.length;i++){
        if(arr[i] === ' ') count++;
    }

    let left = arr.length-1;//快指针
    let right = left + count * 2;//慢指针

    while(left >= 0){//开始遍历数组
        if(arr[left] === ' '){
            arr[right--] = '0';
            arr[right--] = '2';
            arr[right--] = '%';
            left--;
        }else{
            arr[right--] = arr[left--];
        }
        
        
    }
  
    return arr.join('');
};
```

js封装函数

```javascript
var replaceSpace = function(s) {

	return replaceAll(' ','#20')
};
```

# 左旋转字符串

[左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```javascript
var reverseLeftWords = function(s, n) {

    let arr = Array.from(s);

    let leftArr = [];
    let rightArr = [];
    for(let i=0;i<arr.length;i++){
        if(i < n){
            leftArr.push(arr[i]);
            continue;
        } 
        rightArr.push(arr[i]);
    }
    return [...rightArr,...leftArr].join('');
};
```

# 数组中重复的数字

[ 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

> 找出数组中重复的数字。
>
> 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字

思路:由于数字大小的范围已经确定,可以使用**桶排序**的思路解决问题

```javascript
var findRepeatNumber = function(nums) {

    let arr = new Array(nums.length).fill(0);

    for(let i=0;i<nums.length;i++){
        if(arr[nums[i]] != 0) return nums[i];
       
        arr[nums[i]]++;
        
    }


};
```

# 从上到下打印二叉树

[从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```javascript
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
```

思路:再层序遍历基础上加一个奇偶数判断即可

```javascript
var levelOrder = function(root) {

    if(!root) return [];

    let queen = [root];
    let res = [];
    let piles = 1;
    while(queen.length){
        
        let queenLength = queen.length;
        res.push([]);


        for(let i=0;i<queenLength;i++){
            
            let node = queen.shift();

            res[res.length-1].push(node.val);

            node.left && queen.push(node.left)
            node.right && queen.push(node.right)

        }

        if(piles % 2 === 0){
            res[res.length-1].reverse();
        }
        piles++;

       
    }
    return res;
};
```

# 二叉树的镜像

[二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

思路：递归每一个节点,将这个节点的左右子节点替换

```javascript
var mirrorTree = function(root) {

    if(root === null) return null;

    let left = mirrorTree(root.left);
    let right = mirrorTree(root.right);

    root.left = right;
    root.right = left;

    return root;
   

};
```

# 股票的最大利润

[股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

思路:dp找出状态转移方程:`dp[n] = max(prices[i]-price[i-1],prices[i]-prices[i-1]+dp[i-1])`,dp[0]=0;

```javascript
var maxProfit = function(prices) {

    if(!prices.length) return 0;

    let dp = new Array(prices.length).fill(0);
    dp[0] = 0;

    for(let i=1;i<dp.length;i++){

        dp[i] = Math.max(prices[i]-prices[i-1],prices[i]-prices[i-1]+dp[i-1]);

    }

    dp.sort((a,b)=>{
        return a-b;
    })

    return dp[dp.length-1];


};
```

# 连续子数组的最大和

[连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

思路:动态规划

```javascript
var maxSubArray = function(nums) {

    let dp = new Array(nums.length).fill(0);

    dp[0] = nums[0];
    for(let i=1;i<dp.length;i++){
        dp[i] =  Math.max(dp[i-1]+nums[i],nums[i]);
    }
    dp.sort((a,b) => a-b);
    return dp[dp.length-1];

};
```

# 礼物的最大价值

[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 思路:dp创建二维数组,存储棋盘中每一格所能拿到的最大价值,注意礼物的价值是大于0的所以可以少考虑很多东西,状态转移方程是`dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];`

```javascript
var maxValue = function(grid) {


    let dp = new Array(grid.length+1).fill(0).map(()=> new Array(grid[0].length+1).fill(0));
    
    dp[1][1] = grid[0][0];

    for(let i=1;i<=grid.length;i++){
        for(let j=1;j<=grid[0].length;j++){
            
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+grid[i-1][j-1];
        }
    }

    return dp[grid.length][grid[0].length];

};
```

# 第一个只出现一次的字符

[第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

思路:使用map存储键值对,key为字符串的字符,value为这个键值对的key是否有多个,如果为一个，value为true，如果大于1个，value为false

```javascript
var firstUniqChar = function(s) {


    let arr = s.split('')
   
    let map = new Map();

    for(let c of arr){
        map.set(c , !map.has(c))
    }
    for(let c of arr){
        if(map.get(c)) return c
    }
    return ' '

};

```

# 把数字翻译成字符串

[把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

> 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
>

 思路:如果XiXi-1可以被翻译,则可以将XiXi-1当成一个整体,那么此时翻译方法有f(n-2)种,如果不当成一个整体，拆开来看,有f(n-1)种,所以可以被翻译时f(n)=f(n-1)+f(n-2),不可以被翻译时,f(n)=f(n-1)

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203291717973.png)

```javascript
var translateNum = function(num) {


    let str = num.toString();

    let dp = new Array(str.length).fill(0);
    

    dp[0] = 1;
    dp[1] = (str[0]+str[1]) - '0' <=25 ? 2 : 1 ;

    for(let i =2;i<str.length;i++){

        if(str[i-1] !== '0'){
            dp[i] = (str[i-1]+str[i]) - '0' <= 25 ? (dp[i-1]+dp[i-2]) : dp[i-1]
        }else{
            dp[i] = dp[i-1];
        }
        
    }

    return dp[str.length-1];
};
```

# 最长不含重复字符的子字符串

[最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

> 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

思路:hashmap+双指针,遍历字符串,每当发现map中存在当前字符,就更新左指针，最终根据左右指针的之差获得最长子字符串的长度

```javascript
var lengthOfLongestSubstring = function(s) {

    let map = new Map();
    let res = 0;
    let left = -1;
    for(let right=0;right<s.length;right++){
        
        if(map.has(s[right])){

            left = Math.max(left,map.get(s[right]));//更新左指针

        }

        map.set(s[right],right);
        res = Math.max(res,right-left);
       
    }    

    return res;

};

```

# 二维数组中的查找

[二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

![Picture1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:

若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。

```javascript
var findNumberIn2DArray = function(matrix, target) {

    if(!matrix.length) return false;
    let i = 0 , j = matrix[0].length-1;

    while(i < matrix.length && j >=0){
        if(matrix[i][j] === target){
            return true;
        }else if(matrix[i][j] < target){
            i++;
        }else{
            j--;
        }
    }
    return false;

};
```

# N皇后问题

js深浅拷贝恶心死

```javascript

 var solveNQueens = function(n) {

    let res = [];
    let board = new Array(n).fill(0).map(()=> new Array(n).fill('.'));


        //遍历每一种可能性
        const backtrack = (board,row)=>{
        

            if(row === board.length){

                // let board2 = JSON.parse(JSON.stringify(board1)); 
                let board1 = board.slice(); 
                for (let i = 0; i < n; i++) {
                    board1[i] = board1[i].join(''); // 将每一行拼成字符串
                }
                res.push(board1);
                return;
            }  


            for(let i=0;i<board.length;i++){

                if(!isValid(board,row,i)){
                    continue;
                }

                board[row][i] = 'Q';

                backtrack(board,row + 1);

                board[row][i] = '.';

            }


        }

        // 判断此位置放置皇后是否合法
        const isValid = (board1,row,col) =>{//row为行,col为列

            //判断列是否有皇后
            for(let i=row-1;i>=0;i--){
                if(board1[i][col] === 'Q'){
                    return false;
                }
            }
    
            //判断左上斜列是否有皇后
            for(let i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
                if(board1[i][j] === 'Q'){
                    return false;
                }
            }
            //判断右上斜列是否有皇后
            for(let i=row-1,j=col+1;i>=0&&j<n;i--,j++){
                if(board1[i][j] === 'Q'){
                    return false;
                }
            }
    
            return true;
        }
    

        backtrack(board,0);

        return res;
    };
   
```

# 合并两个有序链表

[合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

> 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

思路：递归,如果`l1.val<l2.val`,则将`l1.next`与`l2`合并,如果`l2.val<=l1.val`,则将`l2.next`与`l1`合并,递归结束条件是`！l1`或者`！l2`

```javascript
var mergeTwoLists = function(l1, l2) {

    function mergeTwoQueens(l1,l2){

        if(!l2){
            return l1;
        }else if(!l1){
            return l2;
        }

        if(l1.val <= l2.val){

            l1.next = mergeTwoQueens(l1.next,l2)
            return l1;

        }else if(l1.val > l2.val){
            l2.next = mergeTwoQueens(l1,l2.next)
            return l2;
        }



    }
    return mergeTwoQueens(l1,l2);

};


```

# 调整数组顺序使奇数位于偶数前面

[调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。
>
> 

思路:双指针,left指针累加，right指针累减,共有四种不同情况,分别判断就ok

```javascript
var exchange = function(nums) {

    let right = nums.length-1;
    let left = 0;

    while(left < right){

        if(nums[left] % 2 === 0 && nums[right] % 2 !== 0){//  left偶数 right奇数 合法交换
            [nums[left],nums[right]] = [nums[right],nums[left]];
        }else if (nums[left] % 2 === 0 && nums[right] % 2 === 0){// left偶数 right偶数
            right--;
        }else if (nums[left] % 2 !== 0 && nums[right] % 2 === 0){// left奇数 right偶数
            left++;
            right--;
        }else{
            left++;

        }


    }

    
    return nums;

};
```

# 和为s的两个数字

[和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)

> 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

思路:left指针和right指针,当`nums[left]+nums[right]>target,right--`,

`nums[left]+nums[right]<target,left++`,否则返回正确值

```javascript
var twoSum = function(nums, target) {

  let left = 0;
  let right = nums.length-1;

  while(left < right){

      if(nums[left] + nums[right] > target){
          right--;
      }else if (nums[left] + nums[right] < target){
          left++;
      }else{
          return [nums[left],nums[right]];
      }

  }

};
```

# 翻转单词顺序

[翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

```
输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
```

思路1:字符串切割,将首尾两端空格去掉之后转成数组,然后遍历数组，每次遍历到的值用字符串累加

```javascript
var reverseWords = function(s) {

    let arr = s.trim().split(' ')
    let str = ''
    arr.reverse();

    for(let i =0;i<arr.length;i++){

        if( arr[i] === '') continue;

        if(i !== arr.length-1){
            str  = str + arr[i] + ' ';
        }else{
            str = str + arr[i];
        }
        
    }

    return str

};
```

思路二：双指针,两个指针从字符串右侧开始移动，快指针移到了空格时候,用slice()切割字符串并将单词移入res中，具体看代码

```javascript
var reverseWords = function(s) {

    let str = s.trim();
    let res = [];

    let fast = str.length-1;
    let slow = str.length-1;

    while(fast >= 0){

        while(fast >= 0 && str[fast] !== ' '){
            fast--;
        }
        res.push(str.slice(fast+1,slow+1));
        while( fast >= 0 && str[fast] === ' '){
           fast--;
        }
        slow = fast;


    }

    return res.join(' ')

};


```

# 树的子结构

[树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

> 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
>
> B是A的子结构， 即 A中有出现和B相同的结构和节点值。

思路:回溯,isSubStructure函数负责遍历树A的每个节点,isValid函数负责判断当前A树的节点与B树是否相同

```javascript
var isSubStructure = function(A, B) {

    return (A !== null && B !== null) && (isValid(A,B)|| isSubStructure(A.left,B) || isSubStructure(A.right,B)   )

};

 function isValid(tree,childTree){

        if(!childTree) return true;

        if(!tree) return false;

        if(tree.val !== childTree.val){
            return false;
        }

        return isValid(tree.left,childTree.left) && isValid(tree.right,childTree.right);
        
        

    }

```

# 矩阵中的路径

[矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

思路:遍历棋盘中每个格子,然后用dfs寻找当前格子和周围的格子能不能组成目标单词,要注意的是遍历过的格子不能再遍历

```javascript
var exist = function(board, word) {


    function dfs(i,j,k){

        if(i<0 || i>board.length-1 || j<0 || j>board[0].length-1 || board[i][j] !== word[k]) return false;
        if(k === word.length-1) return true;

        board[i][j] = ' ';
        
        let res = dfs(i+1,j,k+1) || dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i,j-1,k+1);
        
        board[i][j] = word[k];
        
        return res;

    }


    for(let i=0;i<board.length;i++){
        for(let j=0;j<board[0].length;j++){

            if(dfs(i,j,0)) return true;
            

        }
    }

    return false;

};
```

# 二叉搜索树的第k大节点

[二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

思路:用回溯法将每个节点的值存在数组中,然后将数组排序,再输出即可

```javascript
var kthLargest = function(root, k) {

    let res = [];
    let stk = [];

    while(root || stk.length){

        while(root){

            res.push(root.val);
            stk.push(root);
     
            root = root.left;

        }

        root = stk.pop();
        root = root.right;

    }

    res.sort((a,b)=> a-b)

    return res[res.length-k];

};
```

# 扑克牌中的顺子

[扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

> 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
>

思路:用数组把大小王存起来就行了

```javascript
var isStraight = function(nums) {

  
    let kingArr = [];//用来存储大小王
    nums.sort((a,b) => a-b);

    while(nums[0] == 0){
        
        kingArr.push(nums.shift())
    }

    for(let i=1;i<nums.length;i++){

        if(nums[i] -1 !== nums[i-1]){

            let diff = nums[i] - nums[i-1] -1;//获取两个不相隔数字的差
            
            while(kingArr.length){

                if(diff === 0 )break;
                diff--;
                kingArr.pop();

            }
            if(diff != 0) return false;

        }

    }

    return true;



};
```

# 把数组排成最小的数

[把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

> 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

思路:判断两个数哪个在前哪个在后的规则是:`如果x+y<y+x，x在前，y在后`，然后就快排就好了

```javascript
var minNumber = function(nums) {

   
    function quickSort(arr){

        if(!arr.length) return arr;

        let left = [];
        let right = [];

        let basic = arr.shift();
        
        for(let i=0;i<arr.length;i++){

            let strNum = arr[i].toString();
            
            if(strNum + basic  < basic + strNum ){
                left.push(arr[i]);
            }else{
                right.push(arr[i]);
            }
        }



        return quickSort(left).concat(basic,quickSort(right));
    }


    return quickSort(nums).join('');

};
```

# 最小的k个数

[最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

> 输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

思路:快排

```javascript
var getLeastNumbers = function(arr, k) {
    function quickSort(arr){

        if(!arr.length) return arr;

        let left = [];
        let right = [];
        let basis = arr.shift();


        for(let i=0;i<arr.length;i++){

            if(arr[i] < basis){
                left.push(arr[i]);
            }else{
                right.push(arr[i]);
            }


        }

        return quickSort(left).concat(basis,quickSort(right));


    }
    
    let res = quickSort(arr);
    let resReverse = [];
    
    for(let i=0;i<k;i++){

        resReverse.push(res[i])

    }
    return resReverse;

};
```

# 二叉树中和为某一个值的路径

[二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

思路:回溯

```javascript
var pathSum = function(root, target) {

    let path = [];
    let res = [];
    function recur(root,tar){

        if(!root) return;

        path.push(root.val);

        tar -= root.val;

        if(tar ===0 && !root.left && !root.right){

            res.push(path.slice());//阻止浅拷贝bug

        }

        recur(root.left,tar);
        recur(root.right,tar);

        path.pop();



    }

    recur(root,target);
    
    return res;


};

```

