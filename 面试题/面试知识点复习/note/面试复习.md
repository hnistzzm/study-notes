# 面试复习

## 1.JavaScript 基础

![image-20220308142823940](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100087.png)

### 1.执行上下文/作用域/闭包

#### 1.什么是执行上下文?

执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。

---

**执行上下文的类型**

JavaScript共有**三种**执行上下文类型

- **全局执行上下文**
  - 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文
- **函数执行上下文**
  - 每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤
- **Eval函数执行上下文**
  - 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文

---

**执行上下文栈**

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。**每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.**

引擎会执行那些执行上下文位于栈顶的函数.**每当函数执行结束之后，最上层的执行上下文从栈中弹出**，控制流程到达当前栈中的下一个上下文

**一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文**

![image-20220308144717269](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100915.png)

---

**怎么创建执行上下文?**

创建执行上下文有两个阶段:

1. **创建阶段**
2. **执行阶段**

---



**创建阶段**

在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:

1. **this**值的绑定
2. 创建**词法环境**
3. 创建**变量环境**

所以执行上下文在概念上表示如下：

```
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

**This绑定:**

在全局执行上下文中,`this`的值指向全局对象(在浏览器中,全局对象为`window`’)

在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则`this`的值被设置成全局对象或者`undefined`(严格模式)

```java
let foo = {
  baz: function() {
  console.log(this);
  }
}

foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被
             // 对象 'foo' 调用

let bar = foo.baz;

bar();       // 'this' 指向全局 window 对象，因为
             // 没有指定引用对象
```



**词法环境**

[官方的 ES6](https://link.juejin.cn/?target=http%3A%2F%2Fecma-international.org%2Fecma-262%2F6.0%2F) 文档把词法环境定义为

> **词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用**外部**词法环境的空值组成。

词法环境是一种持有**变量符-变量映射**的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)

在词法环境的内部有两个组件:1.**环境记录器**和2.一个**外部环境的引用**

1.**环境记录器**是存储变量和函数声明的实际位置

2.**外部环境的引用**意味着它可以访问其父级词法环境(作用域)



**词法环境**有两种类型: **全局环境**和**函数环境**

- **全局环境**(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是**null**，

  它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且`this`的值指向全局对象

- 在**函数环境**中，函数内部用户定义的变量存储在**环境记录器**中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。



环境记录器也有两种类型:

1. **声明式环境记录器**，用来存储变量、函数和参数
2. **对象环境记录器**,用来定义出现在**全局上下文**中的变量和函数关系

由上不难得知

- 在**全局环境**中,环境记录器是对象环境记录器
- 在**函数环境**中,环境记录器是声明式环境记录器



**注意 :** 对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。

抽象地讲，词法环境在伪代码中看起来像这样：

```
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
```

---

**变量环境**

变量环境其实也是一个**词法环境**,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系

变量环境有着词法环境的所有属性

在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(`let`和`const`)绑定,而后者只用来存储`var`变量绑定

我们看点样例代码来理解上面的概念：

```javascript
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);

```

执行上下文看起来像这样：

```javascript
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>
  },

VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>
  }
}
```



可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined`。

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的**变量声明提升**。

---

**执行阶段**

**在此阶段完成对所有存储的变量的分配,最后执行代码.**

**注意:** 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到`let`变量的值，那么他就会被赋值为`undefined`

---

---

#### 2.作用域(Scope)

**什么是作用域?**

**作用域是指程序源代码中定义变量的区域。**

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用**词法作用域**(lexical scoping)，也就是静态作用域。



我们可以这样理解：**作用域就是一个独立的地盘，让变量不会外泄、暴露出去**。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**

ES6之前,JavaScript只有**全局作用域**和**函数作用域**,ES6之后，新增了**块级作用域**，可以通过`let`和`const`来创建

---



**全局作用域和函数作用域**



**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:

- 最外层函数和在最外层函数外定义的变量拥有全局作用域
- 所有未定义直接赋值的变量默认为全局变量，拥有全局作用域
- 所有window对象的属性拥有全局作用域



全局作用域的**弊端**:容易引发命名冲突，污染全局命名空间

---



**函数作用域**

**在函数内部声明的变量**拥有函数作用域,一般只能在固定的代码片段内可以访问到.



---

作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行

![image-20220308172822751](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100037.png)

值得注意的是：**块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

```javascript
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

---

**块级作用域**

块级作用域可以通过`let`和`const`声明,所声明的变量在指定块作用域·之外无法被访问。

块级作用域在如下情况被创建:

1. 在一个函数内部
2. 在一个代码块内部(‘**{}**’)

块级作用域有以下几个特点:

- 声明变量不会提升的代码块顶部
- 禁止重复声明

---



**作用域链**



在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链

**作用域链的创建和变化**

**函数创建时:**

JavaScript中使用的是词法作用域,**函数的作用域在函数定义的时候就已经决定了**

函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链

举个例子：

```javascript
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```javascript
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

**函数被激活时:**

当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端

这时候执行上下文的作用域链,我们命名为Scope

```javascript
Scope = [AO].concat([[Scope]]);
```

至此,**作用域链创建完毕**

---



#### 3.闭包

**什么是闭包?**

闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.

**本质**:在一个函数内部创建另一个函数

**只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.**

闭包的特性:

- 函数嵌套函数
- 函数内部引用函数外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

---



**闭包是什么时候被创建的？**

因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包

---

**闭包是什么时候被销毁的?**

当他不被任何其他的对象引用的时候，闭包就被销毁

---

**闭包的好处**:

- 保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突
- 在内存中维持一个变量，延长变量的生命周期
- 匿名自执行函数可以减少内存消耗

---

**闭包的缺点:**

- 被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露
- 闭包涉及跨域访问，会导致性能损失

---

**闭包的作用**

- 使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)
- 让函数外部可以操作到函数内部的数据

---

**闭包的原理**

当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被`垃圾回收器`回收。

函数对象中总是有一个`[[scope]]`属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的`[[scope]]`就会引用外围函数（Outer function）的当前作用域对象。

如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。

这就是闭包的原理

---

### 2.this/call/apply/bind



#### 1.this的指向

> 函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚`this`的指向是什么，必须知道相关函数是如何调用的

**在全局上下文中:**

非严格模式和严格模式中this都指向顶层对象(在浏览器中是`window`)

```javascript
this === window // true
'use strict'
this === window;
this.name = '若川';
console.log(this.name); // 若川

```

**普通函数调用模式**

```
// 非严格模式
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
doSth(); // 'window'
复制代码
```

你可能会误以为`window.doSth()`是调用的，所以是指向`window`。虽然本例中`window.doSth`确实等于`doSth`。`name`等于`window.name`。上面代码中这是因为在`ES5`中，全局变量是挂载在顶层对象（浏览器是`window`）中。 事实上，并不是如此。

```
// 非严格模式
let name2 = 'window2';
let doSth2 = function(){
    console.log(this === window);
    console.log(this.name2);
}
doSth2() // true, undefined
复制代码
```

这个例子中`let`没有给顶层对象中（浏览器是window）添加属性，`window.name2和window.doSth`都是`undefined`。

严格模式中，普通函数中的`this`则表现不同，表现为`undefined`。

```
// 严格模式
'use strict'
var name = 'window';
var doSth = function(){
    console.log(typeof this === 'undefined');
    console.log(this.name);
}
doSth(); // true，// 报错，因为this是undefined
复制代码
```

看过的《你不知道的`JavaScript`》上卷的读者，应该知道书上将这种叫做默认绑定。 对`call`，`apply`熟悉的读者会类比为：

```
doSth.call(undefined);
doSth.apply(undefined);
复制代码
```

效果是一样的，`call`，`apply`作用之一就是用来修改函数中的`this`指向为第一个参数的。 第一个参数是`undefined`或者`null`，非严格模式下，是指向`window`。严格模式下，就是指向第一个参数。后文详细解释。
 经常有这类代码（回调函数），其实也是普通函数调用模式。

```
var name = '若川';
setTimeout(function(){
    console.log(this.name);
}, 0);
// 语法
setTimeout(fn | code, 0, arg1, arg2, ...)
// 也可以是一串代码。也可以传递其他函数
// 类比 setTimeout函数内部调用fn或者执行代码`code`。
fn.call(undefined, arg1, arg2, ...);
复制代码
```

**对象中的函数（方法）调用模式**

```
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '若川',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '若川'
student.other.doSth(); // 'other'
// 用call类比则为：
student.doSth.call(student);
// 用call类比则为：
student.other.doSth.call(student.other);
复制代码
```

但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。

```
var studentDoSth = student.doSth;
studentDoSth(); // 'window'
// 用call类比则为：
studentDoSth.call(undefined);
复制代码
```

**`call、apply、bind` 调用模式**

上文提到`call`、`apply`，这里详细解读一下。先通过`MDN`认识下`call`和`apply` [MDN 文档：Function.prototype.call()](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fcall)
 **语法**

```
fun.call(thisArg, arg1, arg2, ...)
复制代码
```

**thisArg**
 在`fun`函数运行时指定的`this`值。需要注意的是，指定的`this`值并不一定是该函数执行时真正的`this`值，如果这个函数处于**非严格模式**下，则指定为`null`和`undefined`的`this`值会自动指向全局对象(浏览器中就是`window`对象)，同时值为原始值(数字，字符串，布尔值)的`this`会指向该原始值的自动包装对象。
 **arg1, arg2, ...**
 指定的参数列表
 **返回值**
 返回值是你调用的方法的返回值，若该方法没有返回值，则返回`undefined`。
 `apply`和`call`类似。只是参数不一样。它的参数是数组（或者类数组）。

根据参数`thisArg`的描述，可以知道，`call`就是改变函数中的`this`指向为`thisArg`，并且执行这个函数，这也就使`JS`灵活很多。严格模式下，`thisArg`是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：

```
var doSth = function(name){
    console.log(this);
    console.log(name);
}
doSth.call(2, '若川'); // Number{2}, '若川'
var doSth2 = function(name){
    'use strict';
    console.log(this);
    console.log(name);
}
doSth2.call(2, '若川'); // 2, '若川'
复制代码
```

虽然一般不会把`thisArg`参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：[面试官问：能否模拟实现`JS`的`call`和`apply`方法](https://juejin.cn/post/6844903728147857415) 就是利用对象上的函数`this`指向这个对象，来模拟实现`call`和`apply`的。感兴趣的读者思考如何实现，再去看看笔者的实现。

`bind`和`call`和`apply`类似，第一个参数也是修改`this`指向，只不过返回值是新函数，新函数也能当做构造函数（`new`）调用。 [MDN Function.prototype.bind](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind)

> `bind()`方法创建一个新的函数， 当这个新函数被调用时`this`键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。

**语法：** fun.bind(thisArg[, arg1[, arg2[, ...]]])
 **参数：** **thisArg** 调用绑定函数时作为this参数传递给目标函数的值。 如果使用`new`运算符构造绑定函数，则忽略该值。当使用`bind`在`setTimeout`中创建一个函数（作为回调提供）时，作为`thisArg`传递的任何原始值都将转换为`object`。如果没有提供绑定的参数，则执行作用域的`this`被视为新函数的`thisArg`。 **arg1, arg2, ...** 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 **返回值** 返回由指定的`this`值和初始化参数改造的原函数拷贝。



**构造函数调用模式**

```
function Student(name){
    this.name = name;
    console.log(this); // {name: '若川'}
    // 相当于返回了
    // return this;
}
var result = new Student('若川');
复制代码
```

使用`new`操作符调用函数，会自动执行以下步骤。

> 1. 创建了一个全新的对象。
> 2. 这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。
> 3. 生成的新对象会绑定到函数调用的`this`。
> 4. 通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
> 5. 如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。

由此可以知道：`new`操作符调用时，`this`指向生成的新对象。 **特别提醒一下，`new`调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象**。

```
function Student(name){
    this.name = name;
    // return function f(){};
    // return {};
}
var result = new Student('若川');
console.log(result); {name: '若川'}
// 如果返回函数f，则result是函数f，如果是对象{}，则result是对象{}
复制代码
```

很多人或者文章都忽略了这一点，直接简单用`typeof`判断对象。虽然实际使用时不会显示返回，但面试官会问到。

---



**总结**

如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向

1. **普通函数调用**:在严格模式下绑定到`undefined`,否则绑定到全局对象
2. **构造函数形式调用**:绑定到新创建的实例对象
3. **对象上的函数调用**:帮到到那个对象
4. **call、apply、bind调用**:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为`null`或者`undefined`，`this`会指向全局对象(浏览器中就是window对象)

**箭头函数的this**:不会使用上文的四条标准的绑定规则,而是**根据当前的词法作用域来决定this。**

箭头函数没有自己的this、super、argument和new.target绑定,所以**必须通过查找作用域链来决定其值**.**如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.**



---

#### 2.call

> call()方法的作用是在使用**一个指定的this值**和**若干个指定的参数值**的前提下调用某个函数或方法

举个栗子

```javascript
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
```

手写实现call方法

```javascript

Function.prototype.ts_call(obj,...args){
    obj = obj || window;
    
    const fn = Symbol(); //创建一个唯一变量,防止属性名冲突
    
    obj[fn] = this; //将属性指定为目标函数
    
    obj[fn](...args);//执行函数
    
    delete obj[fn];//执行后将这个属性删除
}

function fn(age){
    console.log(`我叫${this.name}今年${age}岁了!`);
}
const testobj2 = {
    name: 'zzm'
}
fn.cs_call(testobj2,18)//我叫zzm今年18岁了!

```



#### 3.apply

> apply的方法与call类似,不同之处在于**apply参数以数组的方式传递**,所以call能实现的需求，用apply也同样可以



手写实现apply方法

```javascript
Function.prototype.cs_apply(obj,arg){
    obj = obj || window;
    
    const fn = Symbol();
    
    obj[fn] = this;
    
    obj[fn](...args);
    
    delete obj[fn];
}

function fn(age,hobby){
    console.log(`我叫${this.name}今年${age}岁了我喜欢${hobby}`);
}
const testobj2 = {
    name: 'zzm'
}
fn.cs_apply(testobj2,[18,'睡觉'])//我叫zzm今年18岁了我喜欢睡觉

```



#### 4.bind

> bind()函数会创建一个新函数(称之为绑定函数)

- bind是ES5新增的一个方法
- 传参和call或apply类似
- 不会执行对应的函数，call或apply会自动执行对应的函数
- 返回对函数的引用



**下面例子：**当点击网页时，`EventClick`被触发执行，输出`JSLite.io p1 p2`, 说明`EventClick`中的`this`被`bind`改变成了`obj`对象。如果你将`EventClick.bind(obj,'p1','p2')` 变成 `EventClick.call(obj,'p1','p2')` 的话，页面会直接输出 `JSLite.io p1 p2`

```
var obj = {name:'JSLite.io'};
/**
 * 给document添加click事件监听，并绑定EventClick函数
 * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2
 */
document.addEventListener('click',EventClick.bind(obj,'p1','p2'),false);
//当点击网页时触发并执行
function EventClick(a,b){
    console.log(
            this.name, //JSLite.io
            a, //p1
            b  //p2
    )
}
// JSLite.io p1 p2
```



手写bind

```javascript

Function.prototype.cs_bind = function(obj,...args){

    obj = obj || window;

    const fn = Symbol();
    obj[fn] = this;

    const _this = this;

    const res = function(...innerArgs){

        if(this instanceof _this){//当作构造函数使用
            this[fn] = _this;
            this[fn](...[...args,...innerArgs]);
            delete this[fn];
        }else{//没有当作构造函数使用
            obj[fn](...[...args,...innerArgs])
            delete obj[fn];
        }
    }
    res.prototype = Object.create(this.prototype);
    return res;
}
```



### 3.原型/继承

#### 1.原型

**原型链经典神图**

![image-20220313161148825](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131611904.png)

- function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等
- function Object 就是一个 Object
- function Function 就是 Function
- 以上都是 function，所以 `.__proto__`都是`Function.prototype`
- 再次强调，String、Array、Number、Function、Object都是 function

---

**prototype的定义**

在规范里,prototype被定义为:**给其他对象提供共享属性的对象**

也就是说prototype自己也是对象,只是被用来承担某个只能罢了

**prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用**

---

**函数对象和普通对象**

在JavaScript中,**万物皆对象**,但是不同的对象是存在着差异性的.

在JavaScript中，我们将对象分为函数对象和普通对象,**函数对象就是JavaScript用函数来模拟的类实现**,**Object**和**Function**就是典型的函数对象

```javascript
function fun1(){};
const fun2 = function(){};
const fun3 = new Function('name','console.log(name)');

const obj1 = {};
const obj2 = new Object();
const obj3 = new fun1();
const obj4 = new new Function();


console.log(typeof Object);//function
console.log(typeof Function);//function
console.log(typeof fun1);//function
console.log(typeof fun2);//function
console.log(typeof fun3);//function
console.log(typeof obj1);//object
console.log(typeof obj2);//object
console.log(typeof obj3);//object
console.log(typeof obj4);//object

```

上述代码中，`obj1`，`obj2`，`obj3`，`obj4`都是普通对象，`fun1`，`fun2`，`fun3` 都是 `Function` 的实例，也就是函数对象。

总结:**所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例**

![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131629020.webp)

**JavaScript中万物皆对象,而对象皆出自构造函数**

对于**Function**对象:

```javascript
Function.__proto__ === Function.prototype //true
```



---

**__ proto__**

首先我们需要明确:

- **__ proto__**和**constructor**是**对象**独有的
- **prototype**属性是**函数**独有的

但是在JavaScript中,函数也是一种特殊的对象,**所以函数也拥有`__proto__`和 `constructor`属性**



结合上面我们介绍的 `Object` 和 `Function` 的关系，看一下代码和关系图

```
 function Person(){…};
 let nealyang = new Person(); 
```



![__proto__](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647800.webp)



再梳理上图关系之前，我们再来讲解下`__proto__`。



![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647353.webp)



这里我们需要知道的是，`__proto__`是对象所独有的，并且`__proto__`是**一个对象指向另一个对象**，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的`__proto__`属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的`__proto__`属性所指向的父类的父类上去查找。以此类推，知道找到 `null`。而这个查找的过程，也就构成了我们常说的**原型链**。

**原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合**

---

**prototype**

prototype 被定义为：**给其它对象提供共享属性的对象**。`prototype` 自己也是对象，只是被用以承担某个职能罢了

所有对象都可以作为另一个对象的**prototype**使用



![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131651653.webp)

**任何函数在创建的时候，都会默认给该函数添加 `prototype` 属性.**

---

**constructor**

**constructor**属性也是对象所独有的,**他是一个对象指向同一个函数，这个函数就是该对象的构造函数**



每个对象都有其对应的构造函数,它由本身或者继承而来.

**函数.prototype.constructor**===**该函数本身**



**constructor属性只有prototype对象才有**,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,**而函数创建的对象.proto === 该函数.prototype**

通过函数创建的对象即使自己没有`constructor`属性，它也能通过`__proto__`找到对应的`constructor`，所以**任何对象最终都可以找到其对应的构造函数。**



![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131707239.webp)

---

**原型链**

**原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合**

![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131709481.webp)

---

**typeof**&&**instanceof**原理

**typeof**

用于判断变量的类型,可以判断的类型有:**number**、**undefined**、**String**、**Boolean**、**function**、**object**、**symbol**，但是**typeof在判断object时不能明确的告诉你属于哪一类object**

所以**一般不用typeof来判断object的类型**



为什么**typeof null** 返回’**object**’？

**因为null代表的是空指针对象,所以typeof null 为object**

具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，`null` 的类型标签是 0，`typeof null` 也因此返回 `"object"`

---

**instanceof**

`instanceof` 运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。与 `typeof` 方法不同的是，`instanceof` 方法要求开发者明确地确认对象为某特定类型。

**instanceof**可以判断**一个实例是否是其父类型或者祖先类型的实例。**

**instanceof**是如何进行判断的?

- 表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false



**手写instanceof**

```javascript

function _instanceof(child,father){
    const fp =  father.prototype   
    let cp = child.__proto__
    while(cp){
        if(cp.__proto__ === father.protype){
            return true;
        }
        cp = cp.__proto__;
    }
    return false;
    
}


```





```javascript
console.log(Object instanceof Object);//true 
console.log(Function instanceof Function);//true 
console.log(Number instanceof Number);//false 
console.log(String instanceof String);//false 

console.log(Function instanceof Object);//true 

console.log(Foo instanceof Function);//true 
console.log(Foo instanceof Foo);//false

```

**为什么 `Object` 和 `Function` `instanceof` 自己等于 `true`，而其他类 `instanceof` 自己却又不等于 `true` 呢？如何解释？**

- `Object instanceof Object`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  ObjectL = Object, ObjectR = Object; 
  // 下面根据规范逐步推演
  O = ObjectR.prototype = Object.prototype 
  L = ObjectL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O == L 
  // 返回 true
  
  ```

  

- `Function instanceof Function`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FunctionL = Function, FunctionR = Function; 
  // 下面根据规范逐步推演
  O = FunctionR.prototype = Function.prototype 
  L = FunctionL.__proto__ = Function.prototype 
  // 第一次判断
  O == L 
  // 返回 true
  
  ```

  

- `Foo instanceof Foo`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FooL = Foo, FooR = Foo; 
  // 下面根据规范逐步推演
  O = FooR.prototype = Foo.prototype 
  L = FooL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环再次查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O != L 
  // 再次循环查找 L 是否还有 __proto__ 
  L = Object.prototype.__proto__ = null 
  // 第三次判断
  L == null 
  // 返回 false
  
  ```

  

---

---

#### 2.继承

在JavaScript中,有两类原型继承的方式:**显式继承**和**隐式继承**



---

##### **new**

**new用来创建构造函数的实例对象**

**手写new**

```javascript

function myNew(fn,...args){
    
    let obj = {};
    obj.__proto__ = fn.prototype;//将obj的__proto__赋值为fn的prototype
    fn.apply(obj,args);//将构造函数的this指向这个对象
    return obj;
    
}


```



---

##### **类式继承**

```javascript
function SuperClass() {
    this.superValue = true;
}
SuperClass.prototype.getSuperValue = function(){
    return this.superValue;
}

function SubClass() {
    this.subValue = false;
}

SubClass.prototype = new SuperClass();

SubClass.prototype.getSubValue = function(){
    return this.subValue;
}

const instance = new SubClass();

console.log( instance  instanceof SuperClass);//true
console.log( instance  instanceof SubClass);//true
console.log(SubClass instanceof SuperClass);//false
```

虽然实现起来清晰简洁，但是这种继承方式有两个缺点：

- 由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类
- 由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化

---

##### **构造函数继承**

```javascript

function SuperClass(id) {
    this.books = ['js','css'];
    this.id = id;
}
SuperClass.prototype.showBooks = function(){
    console.log(this.books);
}

function SubClass(id){

    SuperClass.call(this,id)

}

const instance1 = new SubClass(10);
const instance2 = new SubClass(10);

instance1.books.push('html');
console.log(instance1)
console.log(instance2)
instance1.showBooks();//TypeError
```

`SuperClass.call(this,id)`当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型`prototype`，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法

---

##### **组合式继承**

```javascript
function SuperClass(name) {
  this.name = name; 
  this.books = ['Js','CSS'];
}
SuperClass.prototype.getBooks = function() {
    console.log(this.books);
}
function SubClass(name,time) {
  SuperClass.call(this,name);
  this.time = time;
}
SubClass.prototype = new SuperClass();

SubClass.prototype.getTime = function() {
  console.log(this.time);
}
```

如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个`SuperClass`的构造函数执行了两遍就感觉非常的不妥.

##### **原型式继承**

```javascript
function inheritObject(o) {
    //声明一个过渡对象
  function F() { }
  //过渡对象的原型继承父对象
  F.prototype = o;
  //返回过渡对象的实例，该对象的原型继承了父对象
  return new F();
}
```

原型式继承大致的实现方式如上，是不是想到了我们`new`关键字模拟的实现？

其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。

```
var book = {
    name:'js book',
    likeBook:['css Book','html book']
}
var newBook = inheritObject(book);
newBook.name = 'ajax book';
newBook.likeBook.push('react book');
var otherBook = inheritObject(book);
otherBook.name = 'canvas book';
otherBook.likeBook.push('node book');
console.log(newBook,otherBook);
复制代码
```

如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。

所以，我们还有下面的寄生式继承

---

##### **寄生式继承**

```javascript
var book = {
    name:'js book',
    likeBook:['html book','css book']
}
function createBook(obj) {
    //通过原型方式创建新的对象
  var o = new inheritObject(obj);
  // 拓展新对象
  o.getName = function(name) {
    console.log(name)
  }
  // 返回拓展后的新对象
  return o;
}

```

其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。

##### **寄生组合式继承**

回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承

而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。

```javascript
function inheritObject(o) {
  //声明一个过渡对象
  function F() { }
  //过渡对象的原型继承父对象
  F.prototype = o;
  //返回过渡对象的实例，该对象的原型继承了父对象
  return new F();
}

function inheritPrototype(subClass,superClass) {
    // 复制一份父类的原型副本到变量中
  var p = inheritObject(superClass.prototype);
  // 修正因为重写子类的原型导致子类的constructor属性被修改
  p.constructor = subClass;
  // 设置子类原型
  subClass.prototype = p;
}

```

组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。

我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的`constructor`属性指向的不是`subClass`子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起`constructor`属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。

```javascript
function SuperClass(name) {
  this.name = name;
  this.books=['js book','css book'];
}
SuperClass.prototype.getName = function() {
  console.log(this.name);
}
function SubClass(name,time) {
  SuperClass.call(this,name);
  this.time = time;
}
inheritPrototype(SubClass,SuperClass);
SubClass.prototype.getTime = function() {
  console.log(this.time);
}
var instance1 = new SubClass('React','2017/11/11')
var instance2 = new SubClass('Js','2018/22/33');

instance1.books.push('test book');

console.log(instance1.books,instance2.books);
instance2.getName();
instance2.getTime();

```



![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131828871.webp)



这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.

### 4.promise

#### 1.**什么是promise?它用来解决什么问题?**

> Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:**pending**(等待态)，**fulfiled**(成功态),**rejected**(失败态);**状态一旦改变，就不会再改变**(也就是说promise的操作是不可逆的)，**创造promise实例后，他会立即执行**

promise是用来解决两个问题:

- **回调地狱**，减少多层回调嵌套
- **异步执行**(但是不能说promise是异步的)

---

#### 2.**promise用法**

![image-20220313203224725](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132032800.png)

##### **创建promise对象**

promise是一个**构造函数**，可以通过**new**来创建实例对象



Promise的构造函数接收**一个参数**:函数,并且这个函数需要传入**两个参数**:

- **resolve**:异步操作执行成功后的回调函数
- **reject**:异步操作执行失败后的回调函数



```javascript
let p = new Promise((resolve, reject) => {
    //做一些异步操作
    setTimeout(() => {
        console.log('执行完成');
        resolve('我是成功！！');
    }, 2000);
});
```

---

##### **then链式调用**

promise可以通过链式调用来减少多层回调嵌套

```javascript
const p = new Promise((resolve,rehect) =>{
     resolve('ok');          
});
p.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
});
```

---

##### **reject的用法**

把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调

```javascript
    let p = new Promise((resolve, reject) => {
        //做一些异步操作
      setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
      }, 2000);
    });
    p.then((data) => {
            console.log('resolved',data);
        },(err) => {
            console.log('rejected',err);
        }
    ); 

```



then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：

![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132043346.webp)或者![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

---

##### **catch的用法**

catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常

```javascript
p.then((data) => {
    console.log('resolved',data);
    console.log(somedata); //此处的somedata未定义
})
.catch((err) => {
    console.log('rejected',err);
});
```

在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：

![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132046474.webp)

 

也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能



---

##### **Promise.all()**

**用法**:接受一个**数组**参数，里面的值最终都返回Promise对象

**特点**:谁执行**慢**,以谁为准执行回调

```javascript
let Promise1 = new Promise(function(resolve, reject){})
let Promise2 = new Promise(function(resolve, reject){})
let Promise3 = new Promise(function(resolve, reject){})

let p = Promise.all([Promise1, Promise2, Promise3])

p.then(funciton(){
  // 三个都成功则成功  
}, function(){
  // 只要有失败，则失败 
})

```

应用场景:*一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。*

---

##### **Promise.race()**

**用法**:接受一个数组参数,里面的值最终都返回Promise对象

**特点**:谁执行**快**，以谁为准执行回调

```javascript
const promise1 = new Promise(function(resolve, reject) {
    // resolve(1);
    reject(1);
})

const promise2 = new Promise(function(resolve, reject) {
    resolve(2);
})

const promise3 = new Promise(function(resolve, reject) {
    resolve(3);
})

const p = Promise.race([promise1,promise2,promise3])

p
.then((data) => {
    console.log("data",data);
})
.catch((err) => {
    console.log("err",err);
})
```

---

##### **Promise.any()**

**注意**:**Promise.any()尚未被所有浏览器所支持**,node环境下不能使用这个API

**用法**:接受一个数组参数,里面的值最终都返回Promise对象

**特点**:只要有一个promise执行成功,那么就返回那个成功的promise

```javascript
const promise1 = new Promise(function(resolve, reject) {
    // resolve(1);
    reject(1);
})

const promise2 = new Promise(function(resolve, reject) {
    resolve(2);
})

const promise3 = new Promise(function(resolve, reject) {
    resolve(3);
})

const p = Promise.any([promise1,promise2,promise3])

p
.then((data) => {
    console.log("data",data);
})
.catch((err) => {
    console.log("err",err);
})
```

---

#### 3.**async/await**

##### 1.什么是async?

**介绍**:async函数是使用`async`关键字声明的函数。 async函数是[`AsyncFunction`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)构造函数的实例， 并且其中允许使用`await`关键字。`async`和`await`关键字让我们可以用一种更简洁的方式写出基于[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的异步行为，而无需刻意地链式调用`promise`。

**特性**:async函数可能包含0个或者多个[`await`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await)表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用`async` / `await`关键字就可以在异步代码中使用普通的`try` / `catch`代码块。



`async` 函数是 `Generator` 函数的语法糖。使用 关键字 `async` 来表示，在函数内部使用 `await` 来表示异步。相较于 `Generator`，`async` 函数的改进在于下面四点：

- **内置执行器**。`Generator` 函数的执行必须依靠执行器，而 `async` 函数自带执行器，调用方式跟普通函数的调用一样
- **更好的语义**。`async` 和 `await` 相较于 `*` 和 `yield` 更加语义化
- **更广的适用性**。`co` 模块约定，`yield` 命令后面只能是 Thunk 函数或 Promise对象。而 `async` 函数的 `await` 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）
- **返回值是 Promise**。`async` 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 `then()` 方法进行调用



`async`是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。

---

##### 2.async函数怎么用?

**async**用来声明函数是一个异步函数

**await**表示紧跟在后面的表达式需要等待结果



```javascript
async function asyncFn(){
    return 'hello world';
}
asuncFn();
```



**async**函数返回的是一个**promise**对象,状态为**resolved**,参数是**return**的值,所以async函数可以链式调用

```javascript
async function asyncFn() {
    return '我后执行'
}
asyncFn().then(result => {
    console.log(result);//我后执行
})
console.log('我先执行');

```



**async**函数返回的是一个promise对象，如果再执行过程中函数**内部抛出异常**或者返回**reject**，都会是的函数的promise状态变为失败**rejected**，函数抛出异常后，可以通过**catch**接收到返回的错误信息

```javascript
async function asyncFn() {
    return  Promise.reject('reason')
    // throw new Error('has error')
}
asyncFn().then(result => {
    console.log(result);
},reason => {
    console.log(reason);
}).catch(err => {
    console.log(err);
})
console.log('我先执行');

```

async函数接收到的返回值,如果不是**异常**或者**reject**，则判定成功,即**resolve**

以下结果会使async函数判定**失败**:

- 内部含有直接使用并且未声明的变量或者函数。
- 内部抛出一个错误`throw new Error`或者返回`reject`状态`return Promise.reject('执行失败')`
- 函数方法执行出错（🌰：Object使用push()）等等...



async函数如果需要返回结果,都必须使用**return**来返回,不论是**reject**还是**resolve**都需要使用return，不然就会返回一个值为**undefined** 的**resolved**(成功)状态

---

##### 3.await是什么

**await**的意思是**async wait**(异步等待),**await必须配合async使用**，**async函数必须等到内部所有的await命令的promise执行完,才会返回结果**

**打个比方，await是学生，async是校车，必须等人齐了再开车。**

就是说，必须等所有`await` 函数执行完毕后，才会告诉`promise`我成功了还是失败了，执行`then`或者`catch`

```
async function awaitReturn() {     
    return await 1
};
awaitReturn().then(success => console.log('成功', success))
             .catch(error => console.log('失败',error))
```



![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141014457.webp)



async中的await会返回一个**promise**,**下一个await必须等待上一个await返回promise结果状态才会开始执行**

```javascript

let time1;
let time2;

setTimeout(() => {
    time1 = new Date().getTime();
    console.log("第一个函数执行完毕");
}, 1000);

setTimeout(() => {
    time2 = new Date().getTime();
    console.log("第二个函数执行完毕",time2-time1);
}, 2000);


const timeoutFn = function(timeout){ 

	return new Promise(function(resolve){

		return setTimeout(resolve, timeout);
    });
}


async function timeOut() {
    await timeoutFn(1000);
    await timeoutFn(2000);
    console.log("完成");

}
timeOut()
```

不考虑**event loop**(事件循环)

上面的例子中 两个**setTimeout**函数会在**2s**左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，

而**timeOut**函数则需要**3s**左右的时间才会执行完成,这也说明了下一个**await**必须等待上一个**await**返回promise结果状态才会开始执行的结论是正确的

---

**await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise**

 

### 5.深浅拷贝

JavaScript的数据类型分为**基本数据类型**和**引用数据类型**。

对于**基本数据类型**的拷贝，并没有深浅拷贝的区别，我们所说的**深浅拷贝都是对于引用数据类型而言的**。

#### 什么是浅拷贝?

浅拷贝的意思就是只复制引用，而未复制真正的值。

当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变

```javascript
const originArray = [1,2,3,4,5];//数组是引用类型
const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};//对象是引用类型
let originType = [1,2,3];
let originNumber = 1; //基本值类型,不存在深浅拷贝之分

const clonedArray = originArray;
const clonedObj = originObj;
let cloneNumber = originNumber;
let cloneType = originType;

clonedArray.push(6);
clonedObj.a = 'aa';
cloneNumber = 2;
cloneType = {a:'a',b:'b',b:'c'}

console.log(originArray);//[ 1, 2, 3, 4, 5, 6 ]
console.log(originObj);//{ a: 'aa', b: 'b', c: [ 1, 2, 3 ], d: { dd: 'dd' } }
console.log(originNumber);//1
console.log(originType);//当我们改变了变量引用的类型时,这个新变量和被拷贝的变量就没有了任何联系(二者指向不同引用)
```

---

#### 什么是深拷贝？

深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。

**只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。**

目前实现深拷贝的方法不多，主要是两种：

1. 利用 `JSON` 对象中的 `parse` 和 `stringify`
2. 利用递归来实现每一层都重新创建对象并赋值

---



**利用JSON.stringify/parse的方法实现深拷贝**

JSON.stringify的作用是**将一个javascript值转换成json字符串**

JSON.parse的作用是**将一个JSON字符串转换成javascript值或对象**



```javascript
const originArray = [1,2,3,4,5];
const cloneArray = JSON.parse(JSON.stringify(originArray));
console.log(cloneArray === originArray); // false

const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj === originObj); // false

cloneObj.a = 'aa';
cloneObj.c = [1,1,1];
cloneObj.d.dd = 'doubled';

console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
```

上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为**在使用HSON.stringify()时，`undefined`、`function`、`symbol` 会在转换过程中被忽略。。**

如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。

```javascript
const originObj = {
  name:'axuebin',
  sayHello:function(){
    console.log('Hello World');
  }
}
console.log(originObj); // {name: "axuebin", sayHello: ƒ}
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj); // {name: "axuebin"}
```



---

**使用递归的方法实现深拷贝**

递归的思想就很简单了，就是对每一层的数据都实现一次 `创建对象->对象赋值` 的操作

```javascript

//实现深拷贝
function  deepClone(source) {

    const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
    
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            
            if(source[key] && typeof source[key] === 'object'){//如果值是对象就递归
                targetObj[key] = source[key].constructor === 'Array' ? [] : {};
                deepClone(targetObj[key]);
            }else{//如果不是就直接赋值
                targetObj[key] = source[key];
            }
            
        }
    }
    return targetObj;
}

const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
const cloneObj = deepClone(originObj);
console.log(cloneObj === originObj); // false

cloneObj.a = 'aa';
cloneObj.c = [1,1,1];
cloneObj.d.dd = 'doubled';

console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};

const originObj2 = {
    name:'张振明',
    sayHello:function(){
      console.log('Hello World');
    }
  }
  console.log(originObj2); // {name: "张振明", sayHello: ƒ}
  const cloneObj2 = deepClone(originObj2);
  console.log(cloneObj2); // {name: "张振明", sayHello: ƒ}
```

---

#### JavaScript中的拷贝方法

JavaScript数组中有两个方法,**concat**和**slice**,他们都**不会改变原数组**，而是返回一个新数组

所以他们是可以实现对原数组的拷贝的,另外es6新增的`Object.assgn` 方法和 `...` 展开运算符也能实现对对象的拷贝

这里只说明结论,不解释详细过程

**concat**

该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。

**结论：`concat` 只是对数组的第一层进行深拷贝。**

---



**slice**

**结论：`slice` 只是对数组的第一层进行深拷贝。**

---



**Object.assign()**

**结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值**

---



**... 展开运算符**

**结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**

---

#### 总结

1. 赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；
2. JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；
3. `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求；
4. 若想真正意义上的深拷贝，请递归。

---

---

### 6.event loop(事件循环)

在学习事件循环之前,我们应该明白:**JavaScript本质上就是一个单线程语言,一切JavaScript的所谓“多线程”都是用单线程模拟出来的**

#### **什么是事件循环?**

因为js是单线程的,js的任务是按顺序一个一个执行的。但一个任务耗时过长,后面的任务将被阻塞,这是我们不想看到的。所以程序员将任务分为两类:

- **同步任务**
- **异步任务**



**任务执行机制:**

![img](https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141841788.webp)



导图要表达的内容用文字来表述的话：

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入**Event Table**并注册函数。
- 当指定的事情完成时，**Event Table**会将这个函数移入**Event Queue**。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的**Event Loop**(事件循环)。

---

#### 事件循环的一些举例

##### **setTimeout**

setTimeout表示执行一个延时函数,他的特点是可以异步延时执行

```javascript
setTimeout(() => {
    console.log('延时3秒');
},3000)

```

但是在有些情况下,延时并不准确

```javascript
setTimeout(() => {
    task()
},3000)

sleep(10000000)//消耗很多的时间

```



上例中,sleep()函数是一个**同步任务**,他直接在主线程中执行,而setTimeout是个**异步任务**,在任务执行过程中，task()执行的时间却远远大于3s,这时候延时并不准确,这是什么原因?

- `task()`进入Event Table并注册,计时开始。
- 执行`sleep`函数，很慢，非常慢，计时仍在继续。
- 3秒到了，计时事件`timeout`完成，`task()`进入Event Queue，但是`sleep`也太慢了吧，还没执行完，只好等着。
- `sleep`终于执行完了，`task()`终于从Event Queue进入了主线程执行。


---

**setTimeout(fn,0)**

当setTimeout的延时为0时,是不是意味着他会立即执行呢?

答案是:**NO!**

`setTimeout(fn,0)`的含义是，**指定某个任务在主线程最早可得的空闲时间执行**，意思就是不用再等多少秒了，**只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行**

关于`setTimeout`要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

---

##### setInterval

**setTimeout表示执行一个定时函数,每经过单位时间,就执行一次回调函数**

上面说完了`setTimeout`，当然不能错过它的孪生兄弟`setInterval`。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，`setInterval`会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。

唯一需要注意的一点是，对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**`setInterval`的回调函数`fn`执行时间超过了延迟时间`ms`，那么就完全看不出来有时间间隔了**。

---

#### 宏任务(macro-task)和微任务(micro-task)

