面试复习

## 1.JavaScript 基础

![image-20220308142823940](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132100087.png)

### 1.执行上下文/作用域/闭包

#### 1.什么是执行上下文?

执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。

---

**执行上下文的类型**

JavaScript共有**三种**执行上下文类型

- **全局执行上下文**
  - 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文
- **函数执行上下文**
  - 每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤
- **Eval函数执行上下文**
  - 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文

---

**执行上下文栈**

执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。

当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。**每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.**

引擎会执行那些执行上下文位于栈顶的函数.**每当函数执行结束之后，最上层的执行上下文从栈中弹出**，控制流程到达当前栈中的下一个上下文

**一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文**

![image-20220308144717269](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132100915.png)

---

**怎么创建执行上下文?**

创建执行上下文有两个阶段:

1. **创建阶段**
2. **执行阶段**

---



**创建阶段**

在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:

1. **this**值的绑定
2. 创建**词法环境**
3. 创建**变量环境**

所以执行上下文在概念上表示如下：

```
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

**This绑定:**

在全局执行上下文中,`this`的值指向全局对象(在浏览器中,全局对象为`window`’)

在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则`this`的值被设置成全局对象或者`undefined`(严格模式)

```java
let foo = {
  baz: function() {
  console.log(this);
  }
}

foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被
             // 对象 'foo' 调用

let bar = foo.baz;

bar();       // 'this' 指向全局 window 对象，因为
             // 没有指定引用对象
```



**词法环境**

[官方的 ES6](https://link.juejin.cn/?target=http%3A%2F%2Fecma-international.org%2Fecma-262%2F6.0%2F) 文档把词法环境定义为

> **词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用**外部**词法环境的空值组成。

词法环境是一种持有**变量符-变量映射**的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)

在词法环境的内部有两个组件:1.**环境记录器**和2.一个**外部环境的引用**

1.**环境记录器**是存储变量和函数声明的实际位置

2.**外部环境的引用**意味着它可以访问其父级词法环境(作用域)



**词法环境**有两种类型: **全局环境**和**函数环境**

- **全局环境**(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是**null**，

  它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且`this`的值指向全局对象

- 在**函数环境**中，函数内部用户定义的变量存储在**环境记录器**中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。



环境记录器也有两种类型:

1. **声明式环境记录器**，用来存储变量、函数和参数
2. **对象环境记录器**,用来定义出现在**全局上下文**中的变量和函数关系

由上不难得知

- 在**全局环境**中,环境记录器是对象环境记录器
- 在**函数环境**中,环境记录器是声明式环境记录器



**注意 :** 对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。

抽象地讲，词法环境在伪代码中看起来像这样：

```
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
```

---

**变量环境**

变量环境其实也是一个**词法环境**,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系

变量环境有着词法环境的所有属性

在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(`let`和`const`)绑定,而后者只用来存储`var`变量绑定

我们看点样例代码来理解上面的概念：

```javascript
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);

```

执行上下文看起来像这样：

```javascript
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>
  },

VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>
  }
}
```



可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined`。

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的**变量声明提升**。

---

**执行阶段**

**在此阶段完成对所有存储的变量的分配,最后执行代码.**

**注意:** 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到`let`变量的值，那么他就会被赋值为`undefined`

---

---

#### 2.作用域(Scope)

**什么是作用域?**

**作用域是指程序源代码中定义变量的区域。**

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。

JavaScript 采用**词法作用域**(lexical scoping)，也就是静态作用域。



我们可以这样理解：**作用域就是一个独立的地盘，让变量不会外泄、暴露出去**。也就是说**作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。**

ES6之前,JavaScript只有**全局作用域**和**函数作用域**,ES6之后，新增了**块级作用域**，可以通过`let`和`const`来创建

---



**全局作用域和函数作用域**



**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:

- 最外层函数和在最外层函数外定义的变量拥有全局作用域
- 所有未定义直接赋值的变量默认为全局变量，拥有全局作用域
- 所有window对象的属性拥有全局作用域



全局作用域的**弊端**:容易引发命名冲突，污染全局命名空间

---



**函数作用域**

**在函数内部声明的变量**拥有函数作用域,一般只能在固定的代码片段内可以访问到.



---

作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行

![image-20220308172822751](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132100037.png)

值得注意的是：**块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

```javascript
if (true) {
    // 'if' 条件语句块不会创建一个新的作用域
    var name = 'Hammad'; // name 依然在全局作用域中
}
console.log(name); // logs 'Hammad'
```

---

**块级作用域**

块级作用域可以通过`let`和`const`声明,所声明的变量在指定块作用域·之外无法被访问。

块级作用域在如下情况被创建:

1. 在一个函数内部
2. 在一个代码块内部(‘**{}**’)

块级作用域有以下几个特点:

- 声明变量不会提升的代码块顶部
- 禁止重复声明

---



**作用域链**



在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链

**作用域链的创建和变化**

**函数创建时:**

JavaScript中使用的是词法作用域,**函数的作用域在函数定义的时候就已经决定了**

函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链

举个例子：

```javascript
function foo() {
    function bar() {
        ...
    }
}
```

函数创建时，各自的[[scope]]为：

```javascript
foo.[[scope]] = [
  globalContext.VO
];

bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

**函数被激活时:**

当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端

这时候执行上下文的作用域链,我们命名为Scope

```javascript
Scope = [AO].concat([[Scope]]);
```

至此,**作用域链创建完毕**

---



#### 3.闭包

**什么是闭包?**

闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.

**本质**:在一个函数内部创建另一个函数

**只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.**

闭包的特性:

- 函数嵌套函数
- 函数内部引用函数外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

---



**闭包是什么时候被创建的？**

因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包

---

**闭包是什么时候被销毁的?**

当他不被任何其他的对象引用的时候，闭包就被销毁

---

**闭包的好处**:

- 保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突
- 在内存中维持一个变量，延长变量的生命周期
- 匿名自执行函数可以减少内存消耗

---

**闭包的缺点:**

- 被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露
- 闭包涉及跨域访问，会导致性能损失

---

**闭包的作用**

- 使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)
- 让函数外部可以操作到函数内部的数据

---

**闭包的原理**

当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被`垃圾回收器`回收。

函数对象中总是有一个`[[scope]]`属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的`[[scope]]`就会引用外围函数（Outer function）的当前作用域对象。

如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。

这就是闭包的原理

---

### 2.this/call/apply/bind



#### 1.this的指向

> 函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚`this`的指向是什么，必须知道相关函数是如何调用的

**在全局上下文中:**

非严格模式和严格模式中this都指向顶层对象(在浏览器中是`window`)

```javascript
this === window // true
'use strict'
this === window;
this.name = '若川';
console.log(this.name); // 若川

```

**普通函数调用模式**

```javascript
// 非严格模式
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
doSth(); // 'window'

```

你可能会误以为`window.doSth()`是调用的，所以是指向`window`。虽然本例中`window.doSth`确实等于`doSth`。`name`等于`window.name`。上面代码中这是因为在`ES5`中，全局变量是挂载在顶层对象（浏览器是`window`）中。 事实上，并不是如此。

```javascript
// 非严格模式
let name2 = 'window2';
let doSth2 = function(){
    console.log(this === window);
    console.log(this.name2);
}
doSth2() // true, undefined

```

这个例子中`let`没有给顶层对象中（浏览器是window）添加属性，`window.name2和window.doSth`都是`undefined`。

严格模式中，普通函数中的`this`则表现不同，表现为`undefined`。

```javascript
// 严格模式
'use strict'
var name = 'window';
var doSth = function(){
    console.log(typeof this === 'undefined');
    console.log(this.name);
}
doSth(); // true，// 报错，因为this是undefined

```

看过的《你不知道的`JavaScript`》上卷的读者，应该知道书上将这种叫做默认绑定。 对`call`，`apply`熟悉的读者会类比为：

```javascript
doSth.call(undefined);
doSth.apply(undefined);

```

效果是一样的，`call`，`apply`作用之一就是用来修改函数中的`this`指向为第一个参数的。 第一个参数是`undefined`或者`null`，非严格模式下，是指向`window`。严格模式下，就是指向第一个参数。后文详细解释。
 经常有这类代码（回调函数），其实也是普通函数调用模式。

```javascript
var name = '若川';
setTimeout(function(){
    console.log(this.name);
}, 0);
// 语法
setTimeout(fn | code, 0, arg1, arg2, ...)
// 也可以是一串代码。也可以传递其他函数
// 类比 setTimeout函数内部调用fn或者执行代码`code`。
fn.call(undefined, arg1, arg2, ...);
```

**对象中的函数（方法）调用模式**

```javascript
var name = 'window';
var doSth = function(){
    console.log(this.name);
}
var student = {
    name: '若川',
    doSth: doSth,
    other: {
        name: 'other',
        doSth: doSth,
    }
}
student.doSth(); // '若川'
student.other.doSth(); // 'other'
// 用call类比则为：
student.doSth.call(student);
// 用call类比则为：
student.other.doSth.call(student.other);
```

但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。

```javascript
var studentDoSth = student.doSth;
studentDoSth(); // 'window'
// 用call类比则为：
studentDoSth.call(undefined);
```

**`call、apply、bind` 调用模式**

上文提到`call`、`apply`，这里详细解读一下。先通过`MDN`认识下`call`和`apply` [MDN 文档：Function.prototype.call()](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fcall)
 **语法**

```javascript
fun.call(thisArg, arg1, arg2, ...)

```

**thisArg**
 在`fun`函数运行时指定的`this`值。需要注意的是，指定的`this`值并不一定是该函数执行时真正的`this`值，如果这个函数处于**非严格模式**下，则指定为`null`和`undefined`的`this`值会自动指向全局对象(浏览器中就是`window`对象)，同时值为原始值(数字，字符串，布尔值)的`this`会指向该原始值的自动包装对象。
 **arg1, arg2, ...**
 指定的参数列表
 **返回值**
 返回值是你调用的方法的返回值，若该方法没有返回值，则返回`undefined`。
 `apply`和`call`类似。只是参数不一样。它的参数是数组（或者类数组）。

根据参数`thisArg`的描述，可以知道，`call`就是改变函数中的`this`指向为`thisArg`，并且执行这个函数，这也就使`JS`灵活很多。严格模式下，`thisArg`是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：

```javascript
var doSth = function(name){
    console.log(this);
    console.log(name);
}
doSth.call(2, '若川'); // Number{2}, '若川'
var doSth2 = function(name){
    'use strict';
    console.log(this);
    console.log(name);
}
doSth2.call(2, '若川'); // 2, '若川'
```

虽然一般不会把`thisArg`参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：[面试官问：能否模拟实现`JS`的`call`和`apply`方法](https://juejin.cn/post/6844903728147857415) 就是利用对象上的函数`this`指向这个对象，来模拟实现`call`和`apply`的。感兴趣的读者思考如何实现，再去看看笔者的实现。

`bind`和`call`和`apply`类似，第一个参数也是修改`this`指向，只不过返回值是新函数，新函数也能当做构造函数（`new`）调用。 [MDN Function.prototype.bind](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fbind)

> `bind()`方法创建一个新的函数， 当这个新函数被调用时`this`键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。

**语法：** fun.bind(thisArg[, arg1[, arg2[, ...]]])
 **参数：** **thisArg** 调用绑定函数时作为this参数传递给目标函数的值。 如果使用`new`运算符构造绑定函数，则忽略该值。当使用`bind`在`setTimeout`中创建一个函数（作为回调提供）时，作为`thisArg`传递的任何原始值都将转换为`object`。如果没有提供绑定的参数，则执行作用域的`this`被视为新函数的`thisArg`。 **arg1, arg2, ...** 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 **返回值** 返回由指定的`this`值和初始化参数改造的原函数拷贝。



**构造函数调用模式**

```javascript
function Student(name){
    this.name = name;
    console.log(this); // {name: '若川'}
    // 相当于返回了
    // return this;
}
var result = new Student('若川');

```

使用`new`操作符调用函数，会自动执行以下步骤。

> 1. 创建了一个全新的对象。
> 2. 这个对象会被执行`[[Prototype]]`（也就是`__proto__`）链接。
> 3. 生成的新对象会绑定到函数调用的`this`。
> 4. 通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
> 5. 如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。

由此可以知道：`new`操作符调用时，`this`指向生成的新对象。 **特别提醒一下，`new`调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象**。

```javascript
function Student(name){
    this.name = name;
    // return function f(){};
    // return {};
}
var result = new Student('若川');
console.log(result); {name: '若川'}
// 如果返回函数f，则result是函数f，如果是对象{}，则result是对象{}

```

很多人或者文章都忽略了这一点，直接简单用`typeof`判断对象。虽然实际使用时不会显示返回，但面试官会问到。

---



**总结**

如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向

1. **普通函数调用**:在严格模式下绑定到`undefined`,否则绑定到全局对象
2. **构造函数形式调用**:绑定到新创建的实例对象
3. **对象上的函数调用**:帮到到那个对象
4. **call、apply、bind调用**:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为`null`或者`undefined`，`this`会指向全局对象(浏览器中就是window对象)

**箭头函数的this**:不会使用上文的四条标准的绑定规则,而是**根据当前的词法作用域来决定this。**

箭头函数没有自己的this、super、argument和new.target绑定,所以**必须通过查找作用域链来决定其值**.**如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.**



---

#### 2.call

> call()方法的作用是在使用**一个指定的this值**和**若干个指定的参数值**的前提下调用某个函数或方法

举个栗子

```javascript
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
```

手写实现call方法

```javascript

Function.prototype.ts_call(obj,...args){
    obj = obj || window;
    
    const fn = Symbol(); //创建一个唯一变量,防止属性名冲突
    
    obj[fn] = this; //将属性指定为目标函数
    
    obj[fn](...args);//执行函数
    
    delete obj[fn];//执行后将这个属性删除
}

function fn(age){
    console.log(`我叫${this.name}今年${age}岁了!`);
}
const testobj2 = {
    name: 'zzm'
}
fn.cs_call(testobj2,18)//我叫zzm今年18岁了!

```



#### 3.apply

> apply的方法与call类似,不同之处在于**apply参数以数组的方式传递**,所以call能实现的需求，用apply也同样可以



手写实现apply方法

```javascript
Function.prototype.cs_apply(obj,arg){
    obj = obj || window;
    
    const fn = Symbol();
    
    obj[fn] = this;
    
    obj[fn](...args);
    
    delete obj[fn];
}

function fn(age,hobby){
    console.log(`我叫${this.name}今年${age}岁了我喜欢${hobby}`);
}
const testobj2 = {
    name: 'zzm'
}
fn.cs_apply(testobj2,[18,'睡觉'])//我叫zzm今年18岁了我喜欢睡觉

```



#### 4.bind

> bind()函数会创建一个新函数(称之为绑定函数)

- bind是ES5新增的一个方法
- 传参和call或apply类似
- 不会执行对应的函数，call或apply会自动执行对应的函数
- 返回对函数的引用



**下面例子：**当点击网页时，`EventClick`被触发执行，输出`JSLite.io p1 p2`, 说明`EventClick`中的`this`被`bind`改变成了`obj`对象。如果你将`EventClick.bind(obj,'p1','p2')` 变成 `EventClick.call(obj,'p1','p2')` 的话，页面会直接输出 `JSLite.io p1 p2`

```
var obj = {name:'JSLite.io'};
/**
 * 给document添加click事件监听，并绑定EventClick函数
 * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2
 */
document.addEventListener('click',EventClick.bind(obj,'p1','p2'),false);
//当点击网页时触发并执行
function EventClick(a,b){
    console.log(
            this.name, //JSLite.io
            a, //p1
            b  //p2
    )
}
// JSLite.io p1 p2
```



手写bind

```javascript

Function.prototype.cs_bind = function(obj,...args){

    obj = obj || window;

    const fn = Symbol();
    obj[fn] = this;

    const _this = this;

    const res = function(...innerArgs){

        if(this instanceof _this){//当作构造函数使用
            this[fn] = _this;
            this[fn](...[...args,...innerArgs]);
            delete this[fn];
        }else{//没有当作构造函数使用
            obj[fn](...[...args,...innerArgs])
            delete obj[fn];
        }
    }
    res.prototype = Object.create(this.prototype);
    return res;
}
```



### 3.原型/继承

#### 1.原型

**原型链经典神图**

![image-20220313161148825](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131611904.png)

- function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等
- function Object 就是一个 Object
- function Function 就是 Function
- 以上都是 function，所以 `.__proto__`都是`Function.prototype`
- 再次强调，String、Array、Number、Function、Object都是 function

---

**prototype的定义**

在规范里,prototype被定义为:**给其他对象提供共享属性的对象**

也就是说prototype自己也是对象,只是被用来承担某个只能罢了

**prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用**

---

**函数对象和普通对象**

在JavaScript中,**万物皆对象**,但是不同的对象是存在着差异性的.

在JavaScript中，我们将对象分为函数对象和普通对象,**函数对象就是JavaScript用函数来模拟的类实现**,**Object**和**Function**就是典型的函数对象

```javascript
function fun1(){};
const fun2 = function(){};
const fun3 = new Function('name','console.log(name)');

const obj1 = {};
const obj2 = new Object();
const obj3 = new fun1();
const obj4 = new new Function();


console.log(typeof Object);//function
console.log(typeof Function);//function
console.log(typeof fun1);//function
console.log(typeof fun2);//function
console.log(typeof fun3);//function
console.log(typeof obj1);//object
console.log(typeof obj2);//object
console.log(typeof obj3);//object
console.log(typeof obj4);//object

```

上述代码中，`obj1`，`obj2`，`obj3`，`obj4`都是普通对象，`fun1`，`fun2`，`fun3` 都是 `Function` 的实例，也就是函数对象。

总结:**所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例**

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131629020.webp)

**JavaScript中万物皆对象,而对象皆出自构造函数**

对于**Function**对象:

```javascript
Function.__proto__ === Function.prototype //true
```



---

**__ proto__**

首先我们需要明确:

- **__ proto__**和**constructor**是**对象**独有的
- **prototype**属性是**函数**独有的

但是在JavaScript中,函数也是一种特殊的对象,**所以函数也拥有`__proto__`和 `constructor`属性**



结合上面我们介绍的 `Object` 和 `Function` 的关系，看一下代码和关系图

```
 function Person(){…};
 let nealyang = new Person(); 
```



![__proto__](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131647800.webp)



再梳理上图关系之前，我们再来讲解下`__proto__`。



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131647353.webp)



这里我们需要知道的是，`__proto__`是对象所独有的，并且`__proto__`是**一个对象指向另一个对象**，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的`__proto__`属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的`__proto__`属性所指向的父类的父类上去查找。以此类推，知道找到 `null`。而这个查找的过程，也就构成了我们常说的**原型链**。

**原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合**

---

**prototype**

prototype 被定义为：**给其它对象提供共享属性的对象**。`prototype` 自己也是对象，只是被用以承担某个职能罢了

所有对象都可以作为另一个对象的**prototype**使用



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131651653.webp)

**任何函数在创建的时候，都会默认给该函数添加 `prototype` 属性.**

---

**constructor**

**constructor**属性也是对象所独有的,**他是一个对象指向同一个函数，这个函数就是该对象的构造函数**



每个对象都有其对应的构造函数,它由本身或者继承而来.

**函数.prototype.constructor**===**该函数本身**



**constructor属性只有prototype对象才有**,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,**而函数创建的对象.proto === 该函数.prototype**

通过函数创建的对象即使自己没有`constructor`属性，它也能通过`__proto__`找到对应的`constructor`，所以**任何对象最终都可以找到其对应的构造函数。**



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131707239.webp)

---

**原型链**

**原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合**

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131709481.webp)

---

**typeof**&&**instanceof**原理

**typeof**

用于判断变量的类型,可以判断的类型有:**number**、**undefined**、**String**、**Boolean**、**function**、**object**、**symbol**，但是**typeof在判断object时不能明确的告诉你属于哪一类object**

所以**一般不用typeof来判断object的类型**



为什么**typeof null** 返回’**object**’？

**因为null代表的是空指针对象,所以typeof null 为object**

具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 `null` 代表的是空指针（大多数平台下值为 0x00），因此，`null` 的类型标签是 0，`typeof null` 也因此返回 `"object"`

---

**instanceof**

`instanceof` 运算符用来检测 `constructor.prototype` 是否存在于参数 `object` 的原型链上。与 `typeof` 方法不同的是，`instanceof` 方法要求开发者明确地确认对象为某特定类型。

**instanceof**可以判断**一个实例是否是其父类型或者祖先类型的实例。**

**instanceof**是如何进行判断的?

- 表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false



**手写instanceof**

```javascript

function _instanceof(child,father){
    const fp =  father.prototype   
    let cp = child.__proto__
    while(cp){
        if(cp.__proto__ === father.protype){
            return true;
        }
        cp = cp.__proto__;
    }
    return false;
    
}


```





```javascript
console.log(Object instanceof Object);//true 
console.log(Function instanceof Function);//true 
console.log(Number instanceof Number);//false 
console.log(String instanceof String);//false 

console.log(Function instanceof Object);//true 

console.log(Foo instanceof Function);//true 
console.log(Foo instanceof Foo);//false

```

**为什么 `Object` 和 `Function` `instanceof` 自己等于 `true`，而其他类 `instanceof` 自己却又不等于 `true` 呢？如何解释？**

- `Object instanceof Object`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  ObjectL = Object, ObjectR = Object; 
  // 下面根据规范逐步推演
  O = ObjectR.prototype = Object.prototype 
  L = ObjectL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O == L 
  // 返回 true
  
  ```

  

- `Function instanceof Function`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FunctionL = Function, FunctionR = Function; 
  // 下面根据规范逐步推演
  O = FunctionR.prototype = Function.prototype 
  L = FunctionL.__proto__ = Function.prototype 
  // 第一次判断
  O == L 
  // 返回 true
  
  ```

  

- `Foo instanceof Foo`

  ```javascript
  // 为了方便表述，首先区分左侧表达式和右侧表达式
  FooL = Foo, FooR = Foo; 
  // 下面根据规范逐步推演
  O = FooR.prototype = Foo.prototype 
  L = FooL.__proto__ = Function.prototype 
  // 第一次判断
  O != L 
  // 循环再次查找 L 是否还有 __proto__ 
  L = Function.prototype.__proto__ = Object.prototype 
  // 第二次判断
  O != L 
  // 再次循环查找 L 是否还有 __proto__ 
  L = Object.prototype.__proto__ = null 
  // 第三次判断
  L == null 
  // 返回 false
  
  ```

  

---

---

#### 2.继承

在JavaScript中,有两类原型继承的方式:**显式继承**和**隐式继承**



---

##### **new**

**new用来创建构造函数的实例对象**

**手写new**

```javascript

function myNew(fn,...args){
    
    let obj = {};
    obj.__proto__ = fn.prototype;//将obj的__proto__赋值为fn的prototype
    fn.apply(obj,args);//将构造函数的this指向这个对象
    return obj;
    
}


```



---

##### **类式继承**

```javascript
function SuperClass() {
    this.superValue = true;
}
SuperClass.prototype.getSuperValue = function(){
    return this.superValue;
}

function SubClass() {
    this.subValue = false;
}

SubClass.prototype = new SuperClass();

SubClass.prototype.getSubValue = function(){
    return this.subValue;
}

const instance = new SubClass();

console.log( instance  instanceof SuperClass);//true
console.log( instance  instanceof SubClass);//true
console.log(SubClass instanceof SuperClass);//false
```

虽然实现起来清晰简洁，但是这种继承方式有两个缺点：

- 由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类
- 由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化

---

##### **构造函数继承**

```javascript

function SuperClass(id) {
    this.books = ['js','css'];
    this.id = id;
}
SuperClass.prototype.showBooks = function(){
    console.log(this.books);
}

function SubClass(id){

    SuperClass.call(this,id)

}

const instance1 = new SubClass(10);
const instance2 = new SubClass(10);

instance1.books.push('html');
console.log(instance1)
console.log(instance2)
instance1.showBooks();//TypeError
```

`SuperClass.call(this,id)`当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型`prototype`，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法

---

##### **组合式继承**

```javascript
function SuperClass(name) {
  this.name = name; 
  this.books = ['Js','CSS'];
}
SuperClass.prototype.getBooks = function() {
    console.log(this.books);
}
function SubClass(name,time) {
  SuperClass.call(this,name);
  this.time = time;
}
SubClass.prototype = new SuperClass();

SubClass.prototype.getTime = function() {
  console.log(this.time);
}
```

如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个`SuperClass`的构造函数执行了两遍就感觉非常的不妥.

##### **原型式继承**

```javascript
function inheritObject(o) {
    //声明一个过渡对象
  function F() { }
  //过渡对象的原型继承父对象
  F.prototype = o;
  //返回过渡对象的实例，该对象的原型继承了父对象
  return new F();
}
```

原型式继承大致的实现方式如上，是不是想到了我们`new`关键字模拟的实现？

其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。

```javascript
var book = {
    name:'js book',
    likeBook:['css Book','html book']
}
var newBook = inheritObject(book);
newBook.name = 'ajax book';
newBook.likeBook.push('react book');
var otherBook = inheritObject(book);
otherBook.name = 'canvas book';
otherBook.likeBook.push('node book');
console.log(newBook,otherBook);

```

如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。

所以，我们还有下面的寄生式继承

---

##### **寄生式继承**

```javascript
var book = {
    name:'js book',
    likeBook:['html book','css book']
}
function createBook(obj) {
    //通过原型方式创建新的对象
  var o = new inheritObject(obj);
  // 拓展新对象
  o.getName = function(name) {
    console.log(name)
  }
  // 返回拓展后的新对象
  return o;
}

```

其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。

##### **寄生组合式继承**

回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承

而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。

```javascript
function inheritObject(o) {
  //声明一个过渡对象
  function F() { }
  //过渡对象的原型继承父对象
  F.prototype = o;
  //返回过渡对象的实例，该对象的原型继承了父对象
  return new F();
}

function inheritPrototype(subClass,superClass) {
    // 复制一份父类的原型副本到变量中
  var p = inheritObject(superClass.prototype);
  // 修正因为重写子类的原型导致子类的constructor属性被修改
  p.constructor = subClass;
  // 设置子类原型
  subClass.prototype = p;
}

```

组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。

我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的`constructor`属性指向的不是`subClass`子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起`constructor`属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。

```javascript
function SuperClass(name) {
  this.name = name;
  this.books=['js book','css book'];
}
SuperClass.prototype.getName = function() {
  console.log(this.name);
}
function SubClass(name,time) {
  SuperClass.call(this,name);
  this.time = time;
}
inheritPrototype(SubClass,SuperClass);
SubClass.prototype.getTime = function() {
  console.log(this.time);
}
var instance1 = new SubClass('React','2017/11/11')
var instance2 = new SubClass('Js','2018/22/33');

instance1.books.push('test book');

console.log(instance1.books,instance2.books);
instance2.getName();
instance2.getTime();

```



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203131828871.webp)



这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.

### 4.promise

#### 1.**什么是promise?它用来解决什么问题?**

> Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:**pending**(等待态)，**fulfiled**(成功态),**rejected**(失败态);**状态一旦改变，就不会再改变**(也就是说promise的操作是不可逆的)，**创造promise实例后，他会立即执行**

promise是用来解决两个问题:

- **回调地狱**，减少多层回调嵌套
- **异步执行**(但是不能说promise是异步的)

---

#### 2.**promise用法**

![image-20220313203224725](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132032800.png)

##### **创建promise对象**

promise是一个**构造函数**，可以通过**new**来创建实例对象



Promise的构造函数接收**一个参数**:函数,并且这个函数需要传入**两个参数**:

- **resolve**:异步操作执行成功后的回调函数
- **reject**:异步操作执行失败后的回调函数



```javascript
let p = new Promise((resolve, reject) => {
    //做一些异步操作
    setTimeout(() => {
        console.log('执行完成');
        resolve('我是成功！！');
    }, 2000);
});
```

---

##### **then链式调用**

promise可以通过链式调用来减少多层回调嵌套

```javascript
const p = new Promise((resolve,rehect) =>{
     resolve('ok');          
});
p.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
})
.then((data) => {
    console.log(data);
});
```

---

##### **reject的用法**

把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调

```javascript
    let p = new Promise((resolve, reject) => {
        //做一些异步操作
      setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
      }, 2000);
    });
    p.then((data) => {
            console.log('resolved',data);
        },(err) => {
            console.log('rejected',err);
        }
    ); 

```



then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132043346.webp)或者![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

---

##### **catch的用法**

catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常

```javascript
p.then((data) => {
    console.log('resolved',data);
    console.log(somedata); //此处的somedata未定义
})
.catch((err) => {
    console.log('rejected',err);
});
```

在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203132046474.webp)

 

也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能



---

##### **Promise.all()**

**用法**:接受一个**数组**参数，里面的值最终都返回Promise对象

**特点**:谁执行**慢**,以谁为准执行回调

```javascript
let Promise1 = new Promise(function(resolve, reject){})
let Promise2 = new Promise(function(resolve, reject){})
let Promise3 = new Promise(function(resolve, reject){})

let p = Promise.all([Promise1, Promise2, Promise3])

p.then(funciton(){
  // 三个都成功则成功  
}, function(){
  // 只要有失败，则失败 
})

```

应用场景:*一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。*

---

##### **Promise.race()**

**用法**:接受一个数组参数,里面的值最终都返回Promise对象

**特点**:谁执行**快**，以谁为准执行回调

```javascript
const promise1 = new Promise(function(resolve, reject) {
    // resolve(1);
    reject(1);
})

const promise2 = new Promise(function(resolve, reject) {
    resolve(2);
})

const promise3 = new Promise(function(resolve, reject) {
    resolve(3);
})

const p = Promise.race([promise1,promise2,promise3])

p
.then((data) => {
    console.log("data",data);
})
.catch((err) => {
    console.log("err",err);
})
```

---

##### **Promise.any()**

**注意**:**Promise.any()尚未被所有浏览器所支持**,node环境下不能使用这个API

**用法**:接受一个数组参数,里面的值最终都返回Promise对象

**特点**:只要有一个promise执行成功,那么就返回那个成功的promise

```javascript
const promise1 = new Promise(function(resolve, reject) {
    // resolve(1);
    reject(1);
})

const promise2 = new Promise(function(resolve, reject) {
    resolve(2);
})

const promise3 = new Promise(function(resolve, reject) {
    resolve(3);
})

const p = Promise.any([promise1,promise2,promise3])

p
.then((data) => {
    console.log("data",data);
})
.catch((err) => {
    console.log("err",err);
})
```

---

#### 3.**async/await**

##### 1.什么是async?

**介绍**:async函数是使用`async`关键字声明的函数。 async函数是[`AsyncFunction`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction)构造函数的实例， 并且其中允许使用`await`关键字。`async`和`await`关键字让我们可以用一种更简洁的方式写出基于[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)的异步行为，而无需刻意地链式调用`promise`。

**特性**:async函数可能包含0个或者多个[`await`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await)表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用`async` / `await`关键字就可以在异步代码中使用普通的`try` / `catch`代码块。



`async` 函数是 `Generator` 函数的语法糖。使用 关键字 `async` 来表示，在函数内部使用 `await` 来表示异步。相较于 `Generator`，`async` 函数的改进在于下面四点：

- **内置执行器**。`Generator` 函数的执行必须依靠执行器，而 `async` 函数自带执行器，调用方式跟普通函数的调用一样
- **更好的语义**。`async` 和 `await` 相较于 `*` 和 `yield` 更加语义化
- **更广的适用性**。`co` 模块约定，`yield` 命令后面只能是 Thunk 函数或 Promise对象。而 `async` 函数的 `await` 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）
- **返回值是 Promise**。`async` 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 `then()` 方法进行调用



`async`是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。

---

##### 2.async函数怎么用?

**async**用来声明函数是一个异步函数

**await**表示紧跟在后面的表达式需要等待结果



```javascript
async function asyncFn(){
    return 'hello world';
}
asuncFn();
```



**async**函数返回的是一个**promise**对象,状态为**resolved**,参数是**return**的值,所以async函数可以链式调用

```javascript
async function asyncFn() {
    return '我后执行'
}
asyncFn().then(result => {
    console.log(result);//我后执行
})
console.log('我先执行');

```



**async**函数返回的是一个promise对象，如果再执行过程中函数**内部抛出异常**或者返回**reject**，都会是的函数的promise状态变为失败**rejected**，函数抛出异常后，可以通过**catch**接收到返回的错误信息

```javascript
async function asyncFn() {
    return  Promise.reject('reason')
    // throw new Error('has error')
}
asyncFn().then(result => {
    console.log(result);
},reason => {
    console.log(reason);
}).catch(err => {
    console.log(err);
})
console.log('我先执行');

```

async函数接收到的返回值,如果不是**异常**或者**reject**，则判定成功,即**resolve**

以下结果会使async函数判定**失败**:

- 内部含有直接使用并且未声明的变量或者函数。
- 内部抛出一个错误`throw new Error`或者返回`reject`状态`return Promise.reject('执行失败')`
- 函数方法执行出错（🌰：Object使用push()）等等...



async函数如果需要返回结果,都必须使用**return**来返回,不论是**reject**还是**resolve**都需要使用return，不然就会返回一个值为**undefined** 的**resolved**(成功)状态

---

##### 3.await是什么

**await**的意思是**async wait**(异步等待),**await必须配合async使用**，**async函数必须等到内部所有的await命令的promise执行完,才会返回结果**

**打个比方，await是学生，async是校车，必须等人齐了再开车。**

就是说，必须等所有`await` 函数执行完毕后，才会告诉`promise`我成功了还是失败了，执行`then`或者`catch`

```
async function awaitReturn() {     
    return await 1
};
awaitReturn().then(success => console.log('成功', success))
             .catch(error => console.log('失败',error))
```



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203141014457.webp)



async中的await会返回一个**promise**,**下一个await必须等待上一个await返回promise结果状态才会开始执行**

```javascript

let time1;
let time2;

setTimeout(() => {
    time1 = new Date().getTime();
    console.log("第一个函数执行完毕");
}, 1000);

setTimeout(() => {
    time2 = new Date().getTime();
    console.log("第二个函数执行完毕",time2-time1);
}, 2000);


const timeoutFn = function(timeout){ 

	return new Promise(function(resolve){

		return setTimeout(resolve, timeout);
    });
}


async function timeOut() {
    await timeoutFn(1000);
    await timeoutFn(2000);
    console.log("完成");

}
timeOut()
```

不考虑**event loop**(事件循环)

上面的例子中 两个**setTimeout**函数会在**2s**左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，

而**timeOut**函数则需要**3s**左右的时间才会执行完成,这也说明了下一个**await**必须等待上一个**await**返回promise结果状态才会开始执行的结论是正确的

---

**await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise**

 

### 5.深浅拷贝

JavaScript的数据类型分为**基本数据类型**和**引用数据类型**。

对于**基本数据类型**的拷贝，并没有深浅拷贝的区别，我们所说的**深浅拷贝都是对于引用数据类型而言的**。

#### 什么是浅拷贝?

浅拷贝的意思就是只复制引用，而未复制真正的值。

当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变

```javascript
const originArray = [1,2,3,4,5];//数组是引用类型
const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};//对象是引用类型
let originType = [1,2,3];
let originNumber = 1; //基本值类型,不存在深浅拷贝之分

const clonedArray = originArray;
const clonedObj = originObj;
let cloneNumber = originNumber;
let cloneType = originType;

clonedArray.push(6);
clonedObj.a = 'aa';
cloneNumber = 2;
cloneType = {a:'a',b:'b',b:'c'}

console.log(originArray);//[ 1, 2, 3, 4, 5, 6 ]
console.log(originObj);//{ a: 'aa', b: 'b', c: [ 1, 2, 3 ], d: { dd: 'dd' } }
console.log(originNumber);//1
console.log(originType);//当我们改变了变量引用的类型时,这个新变量和被拷贝的变量就没有了任何联系(二者指向不同引用)
```

---

#### 什么是深拷贝？

深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。

**只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。**

目前实现深拷贝的方法不多，主要是两种：

1. 利用 `JSON` 对象中的 `parse` 和 `stringify`
2. 利用递归来实现每一层都重新创建对象并赋值

---



**利用JSON.stringify/parse的方法实现深拷贝**

JSON.stringify的作用是**将一个javascript值转换成json字符串**

JSON.parse的作用是**将一个JSON字符串转换成javascript值或对象**



```javascript
const originArray = [1,2,3,4,5];
const cloneArray = JSON.parse(JSON.stringify(originArray));
console.log(cloneArray === originArray); // false

const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj === originObj); // false

cloneObj.a = 'aa';
cloneObj.c = [1,1,1];
cloneObj.d.dd = 'doubled';

console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
```

上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为**在使用HSON.stringify()时，`undefined`、`function`、`symbol` 会在转换过程中被忽略。。**

如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。

```javascript
const originObj = {
  name:'axuebin',
  sayHello:function(){
    console.log('Hello World');
  }
}
console.log(originObj); // {name: "axuebin", sayHello: ƒ}
const cloneObj = JSON.parse(JSON.stringify(originObj));
console.log(cloneObj); // {name: "axuebin"}
```



---

**使用递归的方法实现深拷贝**

递归的思想就很简单了，就是对每一层的数据都实现一次 `创建对象->对象赋值` 的操作

```javascript

//实现深拷贝
function  deepClone(source) {

    const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
    
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            
            if(source[key] && typeof source[key] === 'object'){//如果值是对象就递归
                targetObj[key] = source[key].constructor === 'Array' ? [] : {};
                deepClone(targetObj[key]);
            }else{//如果不是就直接赋值
                targetObj[key] = source[key];
            }
            
        }
    }
    return targetObj;
}

const originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};
const cloneObj = deepClone(originObj);
console.log(cloneObj === originObj); // false

cloneObj.a = 'aa';
cloneObj.c = [1,1,1];
cloneObj.d.dd = 'doubled';

console.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};
console.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};

const originObj2 = {
    name:'张振明',
    sayHello:function(){
      console.log('Hello World');
    }
  }
  console.log(originObj2); // {name: "张振明", sayHello: ƒ}
  const cloneObj2 = deepClone(originObj2);
  console.log(cloneObj2); // {name: "张振明", sayHello: ƒ}
```

---

#### JavaScript中的拷贝方法

JavaScript数组中有两个方法,**concat**和**slice**,他们都**不会改变原数组**，而是返回一个新数组

所以他们是可以实现对原数组的拷贝的,另外es6新增的`Object.assgn` 方法和 `...` 展开运算符也能实现对对象的拷贝

这里只说明结论,不解释详细过程

**concat**

该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。

**结论：`concat` 只是对数组的第一层进行深拷贝。**

---



**slice**

**结论：`slice` 只是对数组的第一层进行深拷贝。**

---



**Object.assign()**

**结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值**

---



**... 展开运算符**

**结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**

---

#### 总结

1. 赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；
2. JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；
3. `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求；
4. 若想真正意义上的深拷贝，请递归。

---

---

### 6.event loop(事件循环)

在学习事件循环之前,我们应该明白:**JavaScript本质上就是一个单线程语言,一切JavaScript的所谓“多线程”都是用单线程模拟出来的**

#### **什么是事件循环?**

因为js是单线程的,js的任务是按顺序一个一个执行的。但一个任务耗时过长,后面的任务将被阻塞,这是我们不想看到的。所以程序员将任务分为两类:

- **同步任务**
- **异步任务**



**任务执行机制:**

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203141841788.webp)



导图要表达的内容用文字来表述的话：

- 同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入**Event Table**并注册函数。
- 当指定的事情完成时，**Event Table**会将这个函数移入**Event Queue**。
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
- 上述过程会不断重复，也就是常说的**Event Loop**(事件循环)。

---

#### 事件循环的一些举例

##### **setTimeout**

setTimeout表示执行一个延时函数,他的特点是可以异步延时执行

```javascript
setTimeout(() => {
    console.log('延时3秒');
},3000)

```

但是在有些情况下,延时并不准确

```javascript
setTimeout(() => {
    task()
},3000)

sleep(10000000)//消耗很多的时间

```



上例中,sleep()函数是一个**同步任务**,他直接在主线程中执行,而setTimeout是个**异步任务**,在任务执行过程中，task()执行的时间却远远大于3s,这时候延时并不准确,这是什么原因?

- `task()`进入Event Table并注册,计时开始。
- 执行`sleep`函数，很慢，非常慢，计时仍在继续。
- 3秒到了，计时事件`timeout`完成，`task()`进入Event Queue，但是`sleep`也太慢了吧，还没执行完，只好等着。
- `sleep`终于执行完了，`task()`终于从Event Queue进入了主线程执行。


---

**setTimeout(fn,0)**

当setTimeout的延时为0时,是不是意味着他会立即执行呢?

答案是:**NO!**

`setTimeout(fn,0)`的含义是，**指定某个任务在主线程最早可得的空闲时间执行**，意思就是不用再等多少秒了，**只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行**

关于`setTimeout`要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

---

##### setInterval

**setTimeout表示执行一个定时函数,每经过单位时间,就执行一次回调函数**

上面说完了`setTimeout`，当然不能错过它的孪生兄弟`setInterval`。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，`setInterval`会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。

唯一需要注意的一点是，对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**`setInterval`的回调函数`fn`执行时间超过了延迟时间`ms`，那么就完全看不出来有时间间隔了**。

---

#### 宏任务(macro-task)和微任务(micro-task)



除了广义上的同步任务和异步任务,我们对任务有更精细的定义:

- **macro-task(宏任务)**:包括整体代码script,setTimeout\setInterval...
- **micro-task(微任务)**:Promise,Process.nextTick....



核心知识点伪代码;

```javascript
for (const macroTask of macroTaskQueue) {//先执行宏任务
  handleMacroTask();
  
  for (const microTask of microTaskQueue) {//再执行宏任务中的微任务
    handleMicroTask(microTask);
  }
}

```





事件循环,宏任务,微任务的关系图:

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151437172.webp)

用一段代码来说明:

```javascript
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

```

第一轮事件循环流程分析如下：

- 整体script作为第一个宏任务进入主线程，遇到`console.log`，输出1。
- 遇到`setTimeout`，其回调函数被分发到宏任务Event Queue中。我们暂且记为`setTimeout1`。
- 遇到`process.nextTick()`，其回调函数被分发到微任务Event Queue中。我们记为`process1`。
- 遇到`Promise`，`new Promise`直接执行，输出7。`then`被分发到微任务Event Queue中。我们记为`then1`。
- 又遇到了`setTimeout`，其回调函数被分发到宏任务Event Queue中，我们记为`setTimeout2`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
| setTimeout1       | process1          |
| setTimeout2       | then1             |

- 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。
- 我们发现了`process1`和`then1`两个微任务。
- 执行`process1`,输出6。
- 执行`then1`，输出8。

好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从`setTimeout1`宏任务开始：

- 首先输出2。接下来遇到了`process.nextTick()`，同样将其分发到微任务Event Queue中，记为`process2`。`new Promise`立即执行输出4，`then`也分发到微任务Event Queue中，记为`then2`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
| setTimeout2       | process2          |
|                   | then2             |

- 第二轮事件循环宏任务结束，我们发现有`process2`和`then2`两个微任务可以执行。
- 输出3。
- 输出5。
- 第二轮事件循环结束，第二轮输出2，4，3，5。
- 第三轮事件循环开始，此时只剩setTimeout2了，执行。
- 直接输出9。
- 将`process.nextTick()`分发到微任务Event Queue中。记为`process3`。
- 直接执行`new Promise`，输出11。
- 将`then`分发到微任务Event Queue中，记为`then3`。

| 宏任务Event Queue | 微任务Event Queue |
| ----------------- | ----------------- |
|                   | process3          |
|                   | then3             |

- 第三轮事件循环宏任务执行结束，执行两个微任务`process3`和`then3`。
- 输出10。
- 输出12。
- 第三轮事件循环结束，第三轮输出9，11，10，12。

整段代码，共进行了三次事件循环，完整的输出为**1，7，6，8，2，4，3，5，9，11，10，12**。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)

#### ?如何实现一个事件的订阅与发布

### 7.函数式编程

#### 什么是函数式编程？

函数式编程（Functional Programming，后面简称FP），维基百科的定义是：

> 是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。

我来尝试理解下这个定义，好像就是说，在敲代码的时候，我要**把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。而且可以把函数作为输入输出**。感觉好像平常写js时，就是这样的嘛！

**特性:**

1. **函数是一等公民**。就是说函数可以跟其他变量一样，可以作为其他函数的输入输出。喔，回调函数就是典型应用。
2. **不可变量**。就是说，不能用var跟let咯。按这要求，我似乎有点难写代码。
3. **纯函数**。就是没有副作用的函数。这个好理解，就是不修改函数外部的变量。
4. **引用透明**。这个也好理解，就是说同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。
5. **惰性计算**。大意就是：一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。

#### 函数式编程的优劣势

**优势**

1. **更好的管理状态**。因为它的宗旨是无状态，或者说更少的状态。而平常DOM的开发中，因为DOM的视觉呈现依托于状态变化，所以不可避免的产生了非常多的状态，而且不同组件可能还相互依赖。以FP来编程，能最大化的减少这些未知、优化代码、减少出错情况。
2. **更简单的复用**。极端的FP代码应该是每一行代码都是一个函数，当然我们不需要这么极端。我们尽量的把过程逻辑以更纯的函数来实现，固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响。
3. **更优雅的组合**。往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。参考上面第二点，更强的复用性，带来更强大的组合性。
4. 隐性好处。减少代码量，提高维护性。

**劣势**

1. JavaScript不能算是严格意义上的函数式语言，很多函数式编程的特性并没有。比如上文说的数组的惰性链求值。为了实现它就得上工具库，或者自己封装实现，提高了代码编写成本。
2. 跟过程式相比，它并没有提高性能。有些地方，如果强制用FP去写，由于没有中间变量，还可能会降低性能。
3. 代码不易读。这个因人而异，因码而已。特别熟悉FP的人可能会觉得这段代码一目了然。而不熟悉的人，遇到写的晦涩的代码，看着一堆堆lambda演算跟匿名函数 `() => () => ()` 瞬间就懵逼了。看懂代码，得脑子里先演算半小时。
4. 学习成本高。一方面继承于上一点。另一方面，很多前端coder，就是因为相对不喜欢一些底层的抽象的编程语言，才来踏入前端坑，你现在又让他们一头扎入FP，显得手足无措。

#### 函数柯里化(curry)

curry 的概念很简单：**只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。**

 **函数柯里化是指一个函数接收参数但不执行,知道所有参数都接到之后再执行**

**实现一个curry函数**

```javascript
function currying(fn,...args){

    const length = fn.length
    let argArray = [...args]

    const res = function(...args2){

        argArray = [...argArray,...args2]
        //长度相等或者大于fn所需参数就返回执行结果
        if(argArray.length >= length){
            return fn(...argArray)
        }else{
            //长度不相等继续返回函数
            return  res
        }
    }
    return res
  }
  
  
  const add = (a,b,c) =>  a+b+c
  const a = currying(add,1)
  console.log(a(2,3));//output: 6
```

### 8.Service Worker/PWA

### 9.Web Worker

### 10.ES6知识

ES6所增加的知识太多了,给一个传送口

[1.5万字概括ES6全部特性(已更新ES2020) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903959283367950)

![ES6缩略](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151505211.webp)

#### 1.WeakMap和WeakSet

`WeakMap`和`WeakSet`与普通的`Map`和`Set`的区别

- weakmap的key只能是对象,weakset的成员只能是对象
- 储存的对象都是**弱引用**

---



**什么是弱引用？**

**弱引用**：垃圾回收机制有一套自己的回收算法，我们都知道一个函数执行完成后该函数在调用栈中创建的执行上下文会被销毁，这里说的销毁，其实指的就是执行上下文中环境变量、词法变量中的数据存储所占据的内存空间被垃圾回收机制所回收，那么`垃圾回收机制不考虑 WeakSet 对该对象的引用`是不是就意味着垃圾回收机制不会回收 WeakSet 对象里面的数据所占据的内存呢？不！不是的！

**大白话**:当weakmap和weakset中储存的对象不被除weakmap和weakset类型的对象引用时,垃圾机制会直接将此对象回收,而不会考虑weakmap和weakset的感受

## 2.CSS基础

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151559504.webp)

### 1.position

#### 什么是position?

CSS **`position`**属性用于指定一个元素在文档中的定位方式。[`top`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/top)，[`right`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/right)，[`bottom`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom) 和 [`left`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/left) 属性则决定了该元素的最终位置。

<iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 637.156px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe>

**position的属性**

- **static**:表示元素按文档流中本应该放置的位置来排版
- **relative**:表示相对定位
- **absolute**:表示绝对定位
- **fixed**：固定定位
- **sticky**:表示粘性定位

**relative**

**特性**:

- **不脱离文档流**
- 默认参照物为此元素**原位置**

---



**absolute**

特性:

- **脱离文档流**
- 默认参照物为浏览器视窗的**左上角**

绝对定位元素相对于*最近的非 `static` 祖先元素*定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。

可以查看示例

[A Pen by 张振明 (codepen.io)](https://codepen.io/zhangzhenming20020615/pen/mdpJeRe)

---

**fixed**

**特性**

- **脱离文档流**
- 默认参照物为浏览器**视窗位置**

---



**sticky(粘性定位)**

单词sticky的中文意思是“粘性的”，`position:sticky`表现也符合这个粘性的表现。基本上，可以看出是`position:relative`和`position:fixed`的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。

**特性**:

- **当元素没有到达指定的位置时**,position为**relative**
- **当元素到达指定的位置**,position为**fixed**，也就是固定住
- sticky元素的父级元素不能有任何`overflow:visible`以外的overflow设置,否则没有粘滞效果



### 2.行内元素/块级元素

#### 什么是行内元素？

**行内元素只占据它对应标签的边框所包含的空间**

**一般情况下，行内元素只能包含数据和其他行内元素。**

行内元素列表:

- [b](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b), [big](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big), [i](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i), [small](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small), [tt](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt)
- [abbr](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr), [acronym](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym), [cite](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite), [code](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code), [dfn](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn), [em](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em), [kbd](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd), [strong](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong), [samp](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp), [var](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var)
- [a](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a), [bdo](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo), [br](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br), [img](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img), [map](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map), [object](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object), [q](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q), [script](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script), [span](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span), [sub](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub), [sup](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup)
- [button](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button), [input](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input), [label](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label), [select](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select), [textarea](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea)



#### 什么是块级元素

块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”

通常浏览器会在块级元素前后另起一个新行



#### 行内元素与块级元素的区别

块级元素与行内元素有几个关键区别：

- 格式

  默认情况下，块级元素会新起一行。

- 内容模型

  一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。

HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的[内容类别 (en-US)](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories)代替。”块级“类别大致相当于 HTML5 中的[流内容 (en-US)](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#flow_content)类别，而”行内“类别相当于 HTML5 中的[措辞内容 (en-US)](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#phrasing_content)类别，不过除了这两个还有其他类别。

---



#### BFC(块格式化上下文)

**块格式化上下文（Block Formatting Context，BFC）** 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

**官方解释为**:BFC决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用，当涉及到可视化布局时，BFC提供了一个环境，HTML在这个环境中按照一定的规则进行布局

简单来说,BFC是一个完全独立的空间,让空间里的子元素不会影响到外面的布局，反之,外部元素也不会影响到BFC中元素的布局

下列方式会创建**块格式化上下文**：

- 根元素（`<html>）`
- 浮动元素（元素的 [`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float) 不是 `none`）
- 绝对定位元素（元素的 [`position`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/position) 为 `absolute` 或 `fixed`）
- 行内块元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `inline-block`）
- 表格单元格（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-cell`，HTML表格单元格默认为该值）
- 表格标题（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table-caption`，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的 [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `table、``table-row`、 `table-row-group、``table-header-group、``table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）
- [`overflow`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow) 计算值(Computed)不为 `visible` 的块元素
- [`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 值为 `flow-root` 的元素
- [`contain`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain) 值为 `layout`、`content `或 paint 的元素
- 弹性元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `flex` 或 `inline-flex `元素的直接子元素）
- 网格元素（[`display`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/display) 为 `grid` 或 `inline-grid` 元素的直接子元素）
- 多列容器（元素的 [`column-count`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count) 或 [`column-width` (en-US)](https://developer.mozilla.org/en-US/docs/Web/CSS/column-width) 不为 `auto，包括 ``column-count` 为 `1`）
- `column-span` 为 `all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（[标准变更](https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51)，[Chrome bug](https://bugs.chromium.org/p/chromium/issues/detail?id=709362)）。

块格式化上下文包含创建它的元素内部的所有内容.

块格式化上下文对浮动定位（参见 [`float`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/float)）与清除浮动（参见 [`clear`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear)）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（[Margin collapsing](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing)）也只会发生在属于同一BFC的块级元素之间。

**BFC的规则**

- 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）；
- 处于同一个BFC中的元素相互影响，可能会发生margin collapse；
- 每个元素的margin box的左边，与容器块border box的左边相接触(对于**从左往右的格式化**，否则相反)。即使存在浮动也是如此；
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；
- 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
- 浮动盒区域不叠加到BFC上；



**BFC解决了什么问题**

- 使用float脱离文档流发生高度坍塌的问题
- margin边距重叠问题
- 多栏布局时,一栏被另一栏覆盖的问题








---

### 3.flex布局

#### 什么是flex布局?

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151551342.png)

顾名思义,flex布局就是弹性布局,在flex容器中默认存在两条轴，**水平主轴(main axis)**和**垂直的交叉轴(cross axis)**,我们可以通过设置属性将垂直方向变为主轴,水平方向变为交叉轴

在容器内的每个单元块被称为**flex item**,每个项目占据的主轴空间为(main size)，占据的交叉轴的空间为(cross size)

##### flex容器

实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。

```css
.container {
    display: flex | inline-flex;       //可以有两种取值
}
```

**需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。**

有下面六种属性可以设置在容器上，它们分别是：

1. flex-direction
2. flex-wrap
3. flex-flow
4. justify-content
5. align-items
6. align-content

---



**flex-direction**:决定主轴的方向

```css
.container {
    flex-direction: row | row-reverse | column | column-reverse;
}
```

**row**：默认值,主轴为水平方向,起点在左端

**row-reverse**:主轴为水平方向,起点在右端

**column**:主轴为垂直方向,起点在上沿

**column-reverse**：主轴为垂直方向,起点在下端

---



**flex-wrap**：决定容器内项目是否可以换行

默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。

```css
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```

**nowrap**:**默认值**，不换行,即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151603139.png)

**wrap**：换行,当项目主轴总尺寸超过容器时换行,第一行在上方

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151604830.png)

**wrap-reverse**:换行，第一行在下方

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151605328.png)

---



 **flex-flow**:**flex-direction 和 flex-wrap 的简写形式**

```css
.container {
    flex-flow: <flex-direction> || <flex-wrap>;
}
```

**默认值**为: row nowrap

---



 **justify-content：定义了项目在主轴的对齐方式。**

```css
.container {
    justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

假设主轴是**水平方向**,垂直方向同理(左右改为上下)

**flex-start**:左对齐

**flex-end**:右对齐

**center**：居中

**space-between**：两端对齐,项目之间的间隔相等，即剩余空间等分成间隙。

**space-around**：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。

---

**align-items: 定义了项目在交叉轴上的对齐方式**

```css
.container {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

**baseline**:项目的第一行文字的基线对齐

**stretch**:**默认值**  即如果项目未设置高度或者设为 auto，将占满整个容器的高度

---

**align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用**

```css
.container {
    align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

当你 flex-wrap 设置为 **nowrap** 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。

当你 flex-wrap 设置为 **wrap** 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。

##### flex元素属性

有六种属性可运用在 item 项目上：

1. order
2. flex-basis
3. flex-grow
4. flex-shrink
5. flex
6. align-self

 **order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0**

```css
.item {
    order: <integer>;
}
```



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151616010.png)

---



**flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间**

```css
.item {
    flex-basis: <length> | auto;
}
```

默认值：**auto**，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。

<iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/flex-basis.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 639.297px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe>

**当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。**

- 当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。
- 当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。

 **flex-grow: 定义项目的放大比例**

```css
.item {
    flex-grow: <number>;
}
```

**默认值为 0，即如果存在剩余空间，也不放大**



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151627863.png)

当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。



如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)

如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。

当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。

**flex-shrink: 定义了项目的缩小比例**

```css
.item {
    flex-shrink: <number>;
}
```

**默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。**





![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151628761.png)

这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。



同理可得：

如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。

如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。

---

**flex: flex-grow, flex-shrink 和 flex-basis的简写**

flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 **flex 的默认值是 0 1 auto**。

grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。

grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。

---

**lign-self: 允许单个项目有与其他项目不一样的对齐方式**



单个项目覆盖 align-items 定义的属性

默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。

```css
.item {
     align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203151642611.png)

---



[A Pen by 张振明 (codepen.io)](https://codepen.io/pen/)

#### 如何用flex实现九宫格布局

[flex实现九宫格布局 (codepen.io)](https://codepen.io/zhangzhenming20020615/pen/YzYXqWj)

#### flex:1指的是什么？flex属性默认值是什么

`flex:1` 为：`flex: 1 1 0`;

flex属性默认值为:`0 1 auto`

具体代表什么属性 上文有说明

#### 介绍一下flex-shrink和flex-basis属性

---

---



### 4.1px问题

### 5.重绘与回流

参考:[浏览器的重绘和回流]([浏览器的回流与重绘 (Reflow & Repaint) - 掘金 (juejin.cn)](https://juejin.cn/post/6844903569087266823))

在讨论回流与重绘之前，我们要知道：

1. 浏览器使用流式布局模型 (Flow Based Layout)。
2. 浏览器会把`HTML`解析成`DOM`，把`CSS`解析成`CSSOM`，`DOM`和`CSSOM`合并就产生了`Render Tree`。
3. 有了`RenderTree`，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
4. 由于浏览器使用流式布局，对`Render Tree`的计算通常只需要遍历一次就可以完成，但`table`及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用`table`布局的原因之一。

**一句话：回流必将引起重绘，重绘不一定会引起回流。**

#### 1.回流 (Reflow)

当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `scrollIntoView()`、`scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

#### 2.重绘 (Repaint)

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

#### 3.性能影响

**回流比重绘的代价要更高。**

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。

现代浏览器会对频繁的回流或重绘操作进行优化：

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

当你访问以下属性或方法时，浏览器会立刻清空队列：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `width`、`height`
- `getComputedStyle()`
- `getBoundingClientRect()`

因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

#### 4.如何避免

##### 1.CSS

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。

##### 2.JavaScript

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

---



**总结**:会引起元素位置变化的就会reflow，如博主上面介绍的，窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置；不会引起位置变化的，只是在以前的位置进行改变背景颜色等，只会repaint；

---

---

### 6.居中布局

### 7.层叠上下文

> 参考:[彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index - 掘金 (juejin.cn)](https://juejin.cn/post/6844903667175260174#heading-1)



首先，`z-index`属性值并不是在任何元素上都有效果。它**仅在**定位元素（定义了`position`属性，且属性值为非`static`值的元素）上有效果。

判断元素在`Z轴`上的堆叠顺序，不仅仅是直接比较两个元素的`z-index`值的大小，这个堆叠顺序实际由元素的**层叠上下文**、**层叠等级**共同决定。

![image-20220226103650745](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181527715.png)

#### 1.什么是层叠上下文

层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的`X轴`，`Y轴`以及表示层叠的`Z轴`。一般情况下，元素在页面上沿`X轴Y轴`平铺，我们察觉不到它们在`Z轴`上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。

如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在`Z轴`上就“高人一等”，最终表现就是它离屏幕观察者更近。

> **具象的比喻**：你可以把层叠上下文元素理解为理解为**该元素当了官**，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在`Z轴`上更靠上，更靠近观察者。

#### 2.什么是层叠等级

那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)

- 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在`Z轴`上的上下顺序。
- 在其他普通元素中，它描述定义的是这些普通元素在`Z轴`上的上下顺序。

说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在`Z轴`上的上下顺序，那就直接说它描述定义了所有元素在`Z轴`上的上下顺序就OK啊！为什么要分开描述？

为了说明原因，先举个栗子：

> **具象的比喻**：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。

**再类比回“层叠上下文”和“层叠等级”，就得出一个结论：**

1. 普通元素的层叠等级优先由其所在的层叠上下文决定。
2. 层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。

#### 3.如何产生“层叠上下文”

前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？

其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：

1. `HTML`中的根元素`<html></html>`本身j就具有层叠上下文，称为“根层叠上下文”。
2. 普通元素设置`position`属性为**非**`static`值并设置`z-index`属性为具体数值，产生层叠上下文。
3. CSS3中的新属性也可以产生层叠上下文。

---

上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！

1. 首先先看要比较的两个元素是否处于同一个层叠上下文中
   1. 如果是，谁的层叠等级大，谁在上面
   2. 如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级
2. 当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上



---

---

### 8.sass/less

### 9.对盒模型的理解

盒模型

盒模型共有两种:

- 标准盒模型
- IE盒模型



## 3.Vue

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181857871.webp)

### 1.MVVM

#### 1.什么是MVVM?

> Model–View–ViewModel （MVVM） 是一个软件架构设计模式，源于经典的Model-View-Controller(MVC)模式,MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率.

![1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181527689.awebp)

**MVVM**的核心是**ViewModel**层,它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，**该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互**，起呈上启下作用。

**View层**

View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。

**Model 层**

Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。

**ViewModel 层**

**`ViewModel` 是由前端开发人员组织生成和维护的视图数据层**。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。

#### 2.ViewModel有什么好处?

MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。

### 2.生命周期

#### 1.介绍一下Vue生命周期

![1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181527157.awebp)



Vue 实例有一个完整的生命周期，也就是从开始创建实例、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

**各个生命周期的作用**

| 生命周期      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                       |
| created       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用           |
| mounted       | el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子    |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前              |
| updated       | 组件数据更新之后                                             |
| activited     | keep-alive 专属，组件被激活时调用                            |
| deactivated   | keep-alive 专属，组件被销毁时调用                            |
| beforeDestory | 组件销毁前调用                                               |
| destoryed     | 组件销毁后调用                                               |

**beforeCreate**:此时生命周期以及事件已经被初始化但是数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法

**created**：此时数据监测和数据代理已经初始化，可以通过访问vm访问到data中的数据

**beforeMount**：此阶段Vue开始解析模板，生成虚拟DOM(内存中)，但是页面还不能显示解析好的内容，

此时页面呈现的时未经Vue编译的DOM结构，所有对DOM的操作，最终都不奏效

**mouted**:此阶段内存中的虚拟DOM已经转成真实DOM插入页面。页面中呈现的时经过Vue编译的DOM，此时对DOM的操作均有效。至此初始化过程结束，一般再次进行:开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作、

**beforeUpdate**:此时数据是新的，但是页面是旧的，页面尚未和数据保持同步

**updated**:此时页面已经完成了从Model到View的更新，页面数据是新的，页面也是新的，即页面和数据保持同步

**beforeDestory**：此时vm中所有的data、methods、指令等等都处于可用状态，但是马上要执行销毁过程，一般在此阶段:关闭定时器，取消订阅消息、解绑自定义事件等收尾操作

**destoryed**:销毁vm实例



#### 2.nextTick是如何实现的

**什么是nextTick?**

> nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM

**nextTick原理**



#### 3.父子组件挂载时,生命周期的顺序是怎么样的

vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：

- 加载渲染过程

  父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 子组件更新过程

  父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated

- 父组件更新过程

  父 beforeUpdate -> 父 updated

- 销毁过程

  父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed



### 3.数据绑定

#### 1.Vue的双向绑定如何实现

Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：



![1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191107846.webp)



即：

- 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
- Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。

其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

实现一个监听器 **Observer**：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

实现一个解析器 **Compile**：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 **Watcher：Watcher** 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 **Dep**：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。


![1.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191112642.webp)

按我自己的理解就是:当修改数据时,vue会调用dep.notify通知相应的wathcer执行它的update函数,update函数会执行compile中绑定的回调,然会修改dom的值.当修改视图层的数据时,vue通过监听input来获取input中的值并将其赋值给data中的对应属性，修改属性又会触发setter，于是又会执行dep.notify等一系列操作,从而达到双向绑定.

#### 2.Vue如何监听数组或对象的改变

**1.vue会监视data中所有层次的数据**

**2.如何监测对象中的数据？**

​	通过setter事件监视，且要在newVue时就传入要监测的数据

​		(1).在对象后追加的属性，Vue默认不做响应式处理

​		 (2).如需给后添加的属性做响应式，需要使用以下API:

​				Vue.set(target,propertyName/index,value)

​			    vm.$set(target,propertyName/index,value)

 **3.如何监测数组中的数据?**

​     通过包裹数组更新元素的方法实现，本质就是做了两件事:

​			(1).调用原生对应的方法对数组进行更新

​			(2).重新解析模板，进而更新页面

**4.在Vue修改数组中的某个元素需要用到以下方法:**

​		1.使用这些API:push(),pop(),shift(),unshift(),splice(),sort(),erverse()

​        2.Vue.set()或vm.$set

---

#### 3.defineProperty和proxy的区别

**Proxy 的优势如下:**

- Proxy 可以直接监听对象而非属性；
- Proxy 可以直接监听数组的变化；
- Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
- Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；

**Object.defineProperty 的优势如下:**

- 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平



#### 4.Vue中的数据为什么频繁变化但只会更新一次

### 4.状态管理

#### 1.vuex是什么

> 专门在Vue中实现集中式状态(数据)管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理(读/写),也是一种组件间通信的方式，且适用于任意组件间通信

- Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
- 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

#### 2.什么时候使用vuex?

- ​	多个组件依赖同一状态

- ​	来自不同组件的行为需要变更同一状态

#### 3.vuex的工作原理

![vuex](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181658280.png)

vuex包括以下几个模块:

- **State**：定义了应用状态的数据结构，可以在这里设置默认的初始状态。

  1.vuex管理的状态对象(存放数据的对象)

  2.它应该时唯一的

  3.示例代码:

  ```javascript
  const state = {
     // key:value
  }
  ```

- **Getter**：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。

  当state中的数据需要经过加工后再使用时，可以使用getters加工,类似于组件中的计算属性

- **Mutation**：是唯一更改 store 中状态的方法，且必须是同步函数。

  1.值是一个对象，包含多个直接更新state的方法

  2.谁能调用mutations中的方法？如何让调用？

  ​	在action中使用:**commit(‘对应的mutations方法名’)**触发

  3.mutations中方法的特点：不能写异步代码、只能单纯的操作state

  4.示例代码:

  ```javascript
  const mutations = {
     //函数
  }
  ```

- **Action**：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。

  1.值为一个对象，包含多个响应用户动作的回调函数

  2.通过commit()来触发mutation中函数的调用，间接更新state

  3.示例代码:

  ```javascript
  const actions = {
  	//函数
  }
  ```

  

- **Module**：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

---

#### 4.**vuex中4个map方法的使用**

定义:使用vuex提供的map方法可以对组件中的计算属性和方法进行映射，可以大大的减少代码量，提高代码的复用率

##### 1.mapState

理解:用于帮助我们映射state中的数据为计算属性

```javascript
 computed:{
     //借助mapState生成计算属性:count,student,school(对象写法)
     //对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中state内定义的值
      ...mapState({count:'count',student:'student',school:'school'}),
     
     //借助mapState生成计算属性:count,student,school(数组写法)
      ...mapState(['count','student','school']),
    },
```



##### 2.mapGetters

理解:用于帮助我们映射getters中的数据为计算属性

```javascript
 computed:{
     //借助mapGetters生成计算属性:bigCount(对象写法)
     //对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中getters内定义的值
      ...mapState({count:'count',student:'student',school:'school'}),
     
     //借助mapGetters生成计算属性:bigCount(数组写法)
      ...mapGetters(['bigCount'])
    },
```



##### 3.mapActions

理解:用于帮助我们生成与action对话的方法，即：包含$store.dispatch(xxx)的函数

```javascript
   methods:{
     //借助mapActions生成方法:addOdd，addWait(对象写法)
     //对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中actions内定义的方法名
     ...mapActions({addOdd:'addOdd',addWait:'addWait'}),
     
     //借助mapActions生成方法:addOdd，addWait(数组写法)
      ...mapActions(['addOdd','addWait'])
    }
```



##### 4.mapMutations

理解：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数

```javascript
  methods:{
     //借助mapActions生成方法:Add，Reduce(对象写法)
     //对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中mutations内定义的方法名
     ...mapMutations({add:'Add',reduce:'Reduce'}),
     
     //借助mapActions生成方法:Add，Reduce(数组写法)
      ...mapActions(['Add','Reduce'])
    }
```

注意:当我们使用**mapActions**和**mapMutations**方法时，我们需要将dispatch和commit中需要传递的值通过组件中方法传参，例如:

```html
 <button @click="add(n)">+</button>
```

#### 5.vuex的基本使用

案例:点击按钮对数字进行各种操作

![image-20210911201800277](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181716339.png)

我们将求和之后的数字定义为count，存入vuex的临时组件中，每次进行操作从原组件中调用vuex的api，最终完成求和的计算

Count.vue组件:

```html
  <div >
      <h1>当前求和为:{{$store.state.count}}</h1>
      <select v-model.number="n">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
      </select>
      <button @click="add">+</button>
      <button @click="reduce">-</button>
      <button @click="addOdd">当前求和为奇数再加</button>
      <button @click="addWait">等一等再加</button>
  </div>
```

```javascript
export default {
    data(){
      return{
       n:1,//选择框中选择的数字
      }
    },
    methods:{
      add(){
        this.$store.commit('Add',this.n)
      },
      reduce(){
        this.$store.commit('Reduce',this.n)
      },
      addOdd(){
        this.$store.dispatch('addOdd',this.n)
      },
      addWait(){
           this.$store.dispatch('addWait',this.n)
      }
    }
}
```

store中index.js

```javascript
//该文件用于创建Vuex中最核心的store
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
Vue.use(Vuex)
//准备actions--用于响应组件中的动作
const actions = {//action中可以进行异步操作,例如从请求服务器接口
    addOdd(context,value){
        if(context.state.count % 2){
           context.commit('AddOdd',value) 
        }
    },
    addWait(context,value){
        setTimeout(()=>{
            context.commit('AddWait',value) 
        },1000)
    },
}
//准备mutations--用于操作数据(state)
const mutations = {
    Add(state,value){
        state.count += value
    },
    Reduce(state,value){
        state.count -= value
    },
    AddOdd(state,value){
        state.count += value
    },
    AddWait(state,value){
        state.count += value
    }
}
//准备state--用于存储数据
const state = {
    count:1  
}

//创建并暴露store
export default new Vuex.Store({
    actions,
    mutations,
    state
})
```

效果

![GIF 2021-9-11 20-22-35](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181716612.gif)

#### 6.vuex中的数据在页面刷新后消失怎么办?

用sessionstorage 或者 localstorage 存储数据

```
存储： sessionStorage.setItem( '名', JSON.stringify(值) )
使用： sessionStorage.getItem('名') ---得到的值为字符串类型，用JSON.parse()去引号；
```




### 5.组件通信

#### 1.**vue组件间通信有哪几种方式?**

##### 1.**props/$emit**

适用:**父子组件通信**

**父传子**:父组件通过往子组件标签中添加需要传递的数据，子组件使用**props**来接收,**prop只读，不可修改,即单向数据流**

**子传父**:`$emit`绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数

##### **2.ref**

适用:**父子组件通信**

如果ref挂载在普通的DOM元素上,引用指向的就是DOM元素;如**果挂载在子组件上,引用就指向组件实例**

**父组件可以通过this.$ref.xxx来获取子组件实例**

##### 3.$parent/$children

![image](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181616964.webp)

适用于:**父子组件通信**

通过**this.$parent**和**this.$children**来获取对应的父子组件实例

##### 4.EventBus

适用于:**任意组件间通信**

这种方法通过一个空的Vue实例作为中央**事件总线**，用它来触发事件和监听事件，从而实现任意组件之间的通信

发布事件:通过$emit来发布事件

订阅事件:通过$on来订阅事件,当监听到发布的事件后,执行相应的回调

```javascript
//组件1 发布事件
new Vue({
    data:{
        
    },
    methods:{
        emit(){
            this.bus.$emit.sayhello('say','hello')//发布事件
        }
    }
})
//组件2 订阅事件
new Vue({
    data:{},
    mounted(){
      this.bus.$on('say',this.say)//订阅事件  
    },
    methods:{
        say(word){
            console.log(word);
        }
    }
})
```

> eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难

##### 5.$attrs/$listeners

适用于:**隔代组件通信**

`$attrs`：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 inheritAttrs 选项一起使用。

`$listeners`：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件

##### 6.provide/inject

适用于:**隔代组件通信**

`provide`/ `inject` 是`vue2.2.0`新增的api, 简单来说就是父组件中通过`provide`来提供变量, 然后再子组件中通过`inject`来注入变量。

> 注意: 这里不论子组件嵌套有多深, 只要调用了`inject` 那么就可以注入`provide`中的数据，而不局限于只能从当前父组件的props属性中回去数据



##### 7.vuex

适用于:**任意组件间通信**

**Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了`多个视图依赖于同一状态`和`来自不同视图的行为需要变更同一状态`的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上

Vuex的各个模块:

- `state`：用于数据的存储，是store中的唯一数据源
- `getters`：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算
- `mutations`：类似函数，改变state数据的唯一途径，且不能用于处理异步事件
- `actions`：类似于`mutation`，用于提交`mutation`来改变状态，而不直接变更状态，可以包含任意异步操作
- `modules`：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护



##### 8.localStorage/sessionStorage

通过浏览器缓存来实现组件间通信

### 6.Virtual DOM

#### 1.虚拟dom是什么

**虚拟DOM**简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做**DOM对象**

#### 2.为什么需要虚拟dom

**优点：**

- **保证性能下限：** 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
- **无需手动操作 DOM：** 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- **跨平台：** 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

- **无法进行极致优化：** 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。



#### 3.vue的虚拟dom解决了什么问题

- **无需手动操纵dom**
- 虚拟dom可以方便的进行**跨平台**操作，例如在node环境中无法应用真实dom，但是可以使用虚拟dom

#### 4.虚拟DOM的实现原理

虚拟 DOM 的实现原理主要包括以下 3 部分：

- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
- diff 算法 — 比较两棵虚拟 DOM 树的差异；
- pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

### 7.diff

#### 1.实现diff的思路

- 用JS模拟真实DOM节点
- 把虚拟DOM转换成真实DOM插入页面中
- 发生变化时，比较两棵树的差异，生成差异对象
- 根据差异对象更新真实DOM

 



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181739970.webp)

#### 2.vue中的key的作用

1.key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据**新数据**生成**新的虚拟DOM**，随后Vue进行**新虚拟DOM**与**旧虚拟DOM**的差异比较

2.对比规则:

​    (1).**旧虚拟DOM**中找到了与**新虚拟DOM**相同的**key**:

​          ①.若**虚拟DOM**中内容**没有变化**，直接使用之前的**真实DOM**

​          ②.若**虚拟DOM**中**内容变了**，则生成**新的真实DOM**，随后替换掉页面中之前的**真实DOM**

​    (2).**旧虚拟DOM**中未找到与**新虚拟DOM**相同的**key**

​            创建新的**真实DOM**,随后渲染到页面

   3.用**index**作为**key**可能会引发的问题:

​      (1).若对数据进行**逆序添加**、**逆序删除**等**破坏顺序的操作**会产生**没有必要的真实DOM更新**，界					面效果没有问题，**但是执行效率很低**

​	  (2).如果结构中还包含**输入类的DOM**:会产生**错误DOM更新**，**界面有问题**

​	4.开发中如何选择key？

​		(1).最好使用**每条数据的唯一标识**作为**key**，比如id、手机号、身份证号、学号等唯一值

​		(2).如果不存在对数据的**逆序添加**、**逆序删除**等**破坏顺序的操作**，仅用于渲染列表用于展示，					**使用index作为key是没有问题的**

**index作为key和id作为key的区别**

![image-20210819211653838](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181741532.png)

![image-20210819211812731](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203181741864.png)

### 8.Vue computed/watch

#### 1.computed 和 watch 的区别和运用的场景？

**computed：** 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

**watch：** 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

**运用场景：**

- 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
- 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。



### 9.Vue和React有什么不同

##### 相同点：

1，都使用了**Virtual DOM**。

2，都提供了响应式和组件化的视图组件。

3，都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。

##### 不同点：

1，React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。

2，Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。

3，Vue-cli脚手架可进行配置



---

---



## 4.网络

### 1.HTTP

#### 1.常见的状态码和作用

**1xx**

---

**1xx：表示请求已经被接收,但需要进行后续处理**

**100**:表示客户端应该继续发送请求

**101**:表示需要切换协议



**2xx**

---

**请求已成功被服务器接收**

**200**:请求已经成功,请求所希望的响应头或数据体将随此响应返回

**201**：请求已经被实现,并且有一个新的资源已经依据请求的需要而创建

**202**：服务器已经接受请求,但尚未处理

**204**:服务器成功处理了请求,但不需要返回任何实体内容

**205**：服务器成功处理了请求，但不需要返回任何实体内容



**3xx**

---

**通常这类状态码用来重定向,重定向目标在本次响应的location头字段中指明**

**301(永久重定向)**：被请求的资源已经永久的移动到新位置，301通常用于网站迁移时，服务器对旧的URL进行301重定向到新的URL。

**302(临时重定向)**：请求的资源现在临时从不同的uri响应请求

**303**：请求的响应可以在另一个uri上被找到

**★304(资源未被修改)**：表示上次请求至今，文档的内容并没有改变，客户端可以利用这个状态码做出相应的缓存处理



**4xx**

---

**表示客户端发生了错误妨碍了服务器的处理**

**400**：发生了语法错误导致当前请求无法被服务器理解.

**401**:表示当前请求需要用户验证

**403**：表示服务器已经理解请求但是拒绝执行它

**404**：表示请求的资源没有在服务器上被发现

**405**:表示请求的方法不能被用于请求相应的资源

**413**：表示服务器拒绝处理当前请求,因为该请求提交的实体数据大小超过了服务器愿意或者能处理的范围



**5xx**

---

**表示服务器在处理请求的过程中出现了错误**

**500**：通常是代码出错，后台出现bug

**502**：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

**504**：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。注意与502的区别：502是接收到了无效响应比如`Connection Refused`； 504是响应超时，通常是被墙了。

---

#### 2.介绍一下http缓存策略

HTTP的缓存属于客户端缓存,我们人为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件(图片，css，js等)，我们将缓存分为**强制缓存**和**协商缓存**

##### 缓存规则

###### 强制缓存

当缓存数据库中已经有所请求的数据时，客户端直接从缓存数据库中获取数据，当缓存数据库中没有所请求的数据时，客户端才会从服务端获取数据

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191430961.webp)

###### 协商缓存

客户端会从缓存数据库中获取到一个缓存数据的标识,得到标识后请求服务端验证是否失效。如果没有失效服务端会返回304状态码，说明客户端请求的文档还是新鲜的(与缓存文档相同),此时客户端直接从缓存中获取所请求的数据,如果标识失效，服务端会返回更新后的数据

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191439631.webp)

两类缓存机制可以同时存在,强制缓存的优先级高于协商缓存，浏览器在加载资源时，会先判断是否命中**强缓存**再验证是命中**协商缓存**。

---



##### 缓存方案

###### 强制缓存

对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。

**Expires**

这个字段包含了一个时间，过了这个时间，响应将会失效。

也就是说，`Expire` 这个字段表示缓存到期时间，我们来打开一个网站并查看 `Response Header` 看看这个字段：

```
Expires:Fri, 27 Oct 2017 07:55:30 GMT
```

可能在你查看这的时候发现时间不对啊，怎么都已经是过去了 ~

`GMT` 表示的是格林威治时间，和北京时间相差8小时。

上面的这个时间表示的是 `2017年10月27日15:55:30`。

通过设置 `Expire` 来设置缓存有一个致命缺点：

可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。

**Cache-Control**

既然不能设置绝对时间，那我就设置个相对时间呗。

在 `HTTP/1.1` 中，增加了一个字段 `Cache-Control` ，它包含一个 `max-age` 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。

```
Cache-Control:max-age=600
```

这个表示的就是最大有效时间是 `600s` ，对的，它的单位是秒。

`Cache-Control` 除了 `max-age` 属性之外还有一些属性：

- no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。
- no-store：禁止使用缓存，每一次都要重新请求数据。
- public：默认设置。
- private：不能被多用户共享。

现在基本上都会同时设置 `Expire` 和 `Cache-Control` ，`Cache-Control` 的优先级别更高。

---



###### 协商缓存

协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。 对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。

**Last-Modified，If-Modified-Since**

浏览器第一次请求资源的时候，服务器返回的 `header` 上会带有一个 `Last-Modified` 字段，表示资源**最后修改**的时间。

```
Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT
```

同样的，这是一个 `GMT` 的绝对时间。

当浏览器再次请求该资源时，请求头中会带有一个 `If-Modified-Since` 字段，这个值是第一次请求返回的 `Last-Modified` 的值。服务器收到这个请求后，将 `If-Modified-Since` 和当前的 `Last-Modified` 进行对比。如果相等，则说明资源未修改，返回 `304`，浏览器使用本地缓存。

well，这个方法也是有缺点的：

- 最小单位是秒。也就是说如果我短时间内资源发生了改变，`Last-Modified` 并不会发生变化；
- 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 `Last-Modified` 可不这样认为。

所以，后来又引入一个 `Etag`。

**Etag**

`Etag` 一般是由文件内容 `hash` 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 `Etag` 发生改变。

同样地，在浏览器第一次请求资源时，服务器会返回一个 `Etag` 标识。当再次请求该资源时， 会通过 `If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。

**`Last-Modified` 和 `Etag` 是可以同时设置的，服务器会优先校验 `Etag`，如果 `Etag` 相等就会继续比对 `Last-Modified`，最后才会决定是否返回 `304`。**

---

##### **缓存的优点**

- 减少了冗余的数据传递，节省宽带流量
- 减少了服务器的负担，大大提高了网站性能
- 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。

---

当浏览器再次访问一个已经访问过的资源时，它会这样做：

1. 看看是否命中强缓存，如果命中，就直接使用缓存了；
2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；
3. 如果命中协商缓存，服务器会返回 `304` 告诉浏览器使用本地缓存；
4. 否则，返回最新的资源。

---

#### 3.介绍一下keep-alive

##### 1.**什么是keep-alive?**

keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。

在 HTTP/1.0 协议中，如果请求头中包含：

```
Connection: keep-alive
```

则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。

在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：

```
Connection: close
```

keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：

![image-20220319152129292](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191521396.png)

然而天下没有免费的午餐，如果客户端在接收完所有的信息之后还没有关闭连接，则服务端相应的资源还在被占用（尽管已经没用了）。例如 Tomcat 的 BIO 实现中，未关闭的连接会占用对应的处理线程，如果一个长连接实际上已经处理完毕，但关闭的超时时间未到，则该线程会一直被占用（使用 NIO 的实现没有该问题）。

显然，如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择，例如在微服务架构中，通常微服务的使用方和提供方会长期有交流，此时最好开启 keep-alive。

在一些 TPS/QPS 很高的 REST 服务中，如果使用的是短连接（即没有开启keep-alive），则很可能发生客户端端口被占满的情形。这是由于短时间内会创建大量TCP 连接，而在 TCP 四次挥手结束后，客户端的端口会处于 TIME_WAIT一段时间(2*MSL)，这期间端口不会被释放，从而导致端口被占满。这种情况下最好使用长连接。



### 2.DNS

#### 什么是DNS?

**DNS（Domain Name System，域名系统）**，最初，由于ip长且难记，通过ip访问网站不方便。。所以后来通过发明了DNS服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为ip。这样我们实际访问的就是对应的ip地址啦。

抽象点**DNS就是 一个记录ip地址的超级分布式数据库。**

#### DNS域名解析过程

当用户在浏览器中输入www.baidu.com时

- 第1步，查找**浏览器缓存**。

  > 浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。

- 第2步，查找**系统缓存**。

  > 如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。

- 第3步，查找**路由器缓存**。

  > 如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。

- 第4步，查找**ISP DNS 缓存**。

  > 运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有"DNS服务器地址"这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。

- 第5步，**递归搜索**。

  > 　最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。(2)根域将所要查询域名中的顶级域（假设要查询ke.qq.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。(3) 本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。(4) com域服务器再将域名中的二级域（即ke.qq.com中的qq）的IP地址返回给本地DNS。(5) 本地DNS再向二级域发送请求进行查询。(6) 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。

#### DNS的安全问题

1、DNS欺骗：DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。

- 缓存感染：黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。
  - DNS信息劫持：入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。
  - DNS重定向：攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限

2、拒绝服务攻击 　　黑客主要利用一些DNS软件的漏洞，如在BIND 9版本（版本9.2.0以前的 9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。

3、分布式拒绝服务攻击 　　DDOS 攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范，更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。

4、缓冲区漏洞溢出攻击 　　黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。



#### DNS有关的网络性能优化

1、减少DNS查找，避免重定向 　　浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：

- 服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。

- 浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。

- 浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。

  2、DNS的预解析

  - 可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析

```
 <meta http-equiv="x-dns-prefetch-control" content="on" />
```

- 可以使用link标签来强制对DNS做预解析:

```
 <link rel="dns-prefetch" href="http://ke.qq.com/" />
```

- 当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）

本文是前端与计算机网络培训的一点总结，关于DNS解析过程做了简短的介绍，相关的安全防范和网络性能优化，还需要更多的学习。

### 3.TCP

#### 什么是TCP/IP?

**TCP/IP是一类协议系统。他是用于网络通信的一套协议集合**

传统上来说TCP/IP被认为是一个四层协议

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191608064.webp)

**1网络接口层:**

**主要是指物理层次的一些接口,比如电缆等．**

2) **网络层:**

**提供独立于硬件的逻辑寻址,实现物理地址与逻辑地址的转换．**

**在 TCP / IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）.**

3) **传输层:**

**为网络提供了流量控制,错误控制和确认服务.**

**在 TCP / IP 协议族中有两个互不相同的传输协议： TCP（传输控制协议）和 UDP（用户数据报协议）.**

4) **应用层:**

**为网络排错,文件传输,远程控制和 Internet 操作提供具体的应用程序**

#### TCP的三次握手

##### 三次握手流程

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191611193.webp)



- 客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN
- 服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）
- 客户端发送ACK确认收到回复（序列号为服务端序列号+1）

##### 为什么是三次握手?

tcp连接是全双工的，数据在两个方向上能同时传递。

所以要**确保双方，同时能发数据和收数据**

**第一次握手**：证明了发送方能发数据

**第二次握手**：ack确保了接收方能收数据，syn确保了接收方能发数据

**第三次握手**：确保了发送方能收数据

实际上是四个维度的信息交换，不过中间两步合并为一次握手了。

四次握手浪费，两次握手不能保证“双方同时具备收发功能”

#### TCP的四次挥手

##### 四次挥手流程

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191637291.webp)



- 主动关闭的一方发送FIN，表示要单方面关闭数据的传输
- 服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）
- 等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输
- 客户端回复ACK以确认回复

##### 为什么是四次挥手?

- 因为tcp连接是全双工的，数据在两个方向上能同时传递。
- 同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。
- 因此每个方向都要单独关闭，且收到关系通知需要发送确认回复

### TCP建立连接和关闭连接对应的状态

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203191643424.webp)

### 4.HTTPS

#### HTTPS的工作原理

**什么是HTTPS?**

**HTTPS是在HTTP上建立SSL加密层并对传输数据进行加密。是HTTP协议的安全版**

现在他被广泛用于万维网上安全敏感的通讯，例如交易支付方面

HTTPS的主要作用是:

- 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全
- 对网站服务器进行真实身份认证

**为什么需要https?**

原本的http协议中有可能存在信息窃取或者身份伪装等安全问题。使用https通信机制可以有效地结解决这个问题。

**http协议存在的问题:**

- 通信使用明文(不加密),可能会被窃听
- 无法证明报文的完整性，所以可能遭篡改
- 不验证通信方的身份，因此有可能遭遇伪装

**https的优势:**

- **数据隐私性**：内容经过堆成加密，每个连接生成一个唯一的加密密匙
- **数据完整性**：内容传输经过完整性校验
- **身份认证**：第三方无法伪造服务器(客户端)身份

#### HTTPS和HTTP有什么区别

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203201056419.webp)

HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。

通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，**所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP**。

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**。

- HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202203201057264.webp)

关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。



- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;
- HTTPS需要用到SSL证书，而HTTP不用;
- HTTPS标准端口443，HTTP标准端口80;
- HTTPS基于传输层，HTTP基于应用层;
- HTTPS在浏览器显示绿色安全锁，HTTP没有显示;



### 5.CDN

#### CDN是什么?

CDN的全称是Content Delivery Network，即**内容分发网络**。

**其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定**。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

在不同地域的用户访问网站的响应速度存在差异,为了提高用户访问的响应速度、优化现有Internet中信息的流动,需要在用户和服务器间加入中间层CDN. 使用户能以最快的速度，从最接近用户的地方获得所需的信息，彻底解决网络拥塞，提高响应速度，是目前大型网站使用的流行的应用方案.

**CDN的基本工作过程：**

- 当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。
- CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。
- 用户向CDN的全局负载均衡设备发起URL访问请求。
- CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。
- 基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备：
- 根据用户IP地址，判断哪一个边缘节点距用户最近；
- 根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；
- 查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。
- 全局负载均衡设备把服务器的IP地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

**CDN的应用场景:**

- 用户量大的直播平台，需要快速、低延迟的获取各类直播信息
- 电子商务网站
- 大型企业

既然CDN的核心作用是提高网络的访问速度，那么其用户也就是访问量很大的网站，例如ICP 、ISP、大型企业、电子商务网站和政府网站等。利用CDN技术，这些网站无需投资昂贵的各类服务器，设立分站点。通过采用CDN，CDN将负责信息传递工作，保证信息正常传输，而技术人员只需要维护网站内容，不需要考虑流量问题。这样，网站可保证用户得到更多的新业务，可以快速访问网络上的内容，获得更好的服务质量。举个例子来讲，对于访问量比较大，而被访问内容更新周期比较长的网站，如政府网站，用户往往进行大量的查询工作。这类网站比较适合采用CDN。还有，大家是否注意到，在所谓的宽带社区中，瓶颈是社区的对外出口。这样，如果采用CDN无疑对社区用户使用视频点播、网络教育等宽带应用提供了保证。




### 6.从输入url到页面展示发生了什么

总体来说分为以下几个过程:

1. **DNS解析**
2. **TCP连接**
3. **发送HTTP请求**
4. **服务器处理请求并返回HTTP报文**
5. **浏览器解析渲染页面**
6. **连接结束**

具体过程：

1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL 
2. 用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得
3. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 
4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程
5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。
6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输
8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层
9. 底层通过物理网络传输给目的服务器主机 
10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 
11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 
12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 
13. **数据传输完成，TCP四次挥手断开连接**。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive 
14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 
15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 
17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 
18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

## 5.网络安全

### 1.跨域

#### **什么是同源策略?**

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![url的组成](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031348433.webp)

**同源策略的限制内容?**

- Cookie、LocalStorage、IndexedDB等储存性内容
- DOM节点
- AJAX请求,请求发送后会被浏览器拦截

有三个标签允许跨域加载资源:

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

**常见跨域场景**

当协议、子域名、主域名、端口号中任意一个不相同时,都算作不同域.不同域之间相互请求资源，就算作**跨域**

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031353563.webp)

**如果请求跨域了,那么请求到底发出去了吗？**

跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

结论是:**跨域请求可以发送给服务端,并且服务能响应正确结果,但是再返回途中会被浏览器拦截**

---

#### 跨域解决方案

##### 1.JSONP

**原理**:利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。

**优点**:简单,兼容性骄傲,可以用于解决主流浏览器的跨域数据访问的问题

**缺点**:仅支持get方法(因为只能通过url传递参数)，具有局限性,容易遭受xss攻击

**实现**：

- 创建一个script标签,并将script标签的url赋值为我们想要请求的服务器API接口,并且在url上补齐需要传递的参数和需要执行的回调函数名称。
- 当script标签被创建后,浏览器会根据src向服务器发起请求,服务器收到请求后把需要响应的数据和回调函数拼接成一个字符串并响应(例如需要响应的数据是是`zzm`,回调函数名是`Hello`,那就拼接成`Hello(zzm)`)
- 服务端接收到响应后会执行返回的`Hello(zzm)`，那么这个时候就可以拿到服务端响应的数据(这个数据是zzm),执行promise的then方法就可以拿到数据

```javascript
//index.html(客户端)
 function jsonp({url,params,callback}){

        return new Promise((resolve,reject) => {
            let script = document.createElement('script');

            window[callback] = function(data){//函数形参为要从服务器获取的目标数据
                resolve(data)
                document.body.removeChild(script);
            }

            params = {...params,callback};
            let arrs = [];
            for (const key in params) {
               arrs.push(`${key}=${params[key]}`)
            }
            script.src = `${url}?${arrs.join('&')}` //将src拼接
            document.body.appendChild(script);
        })

    }

    jsonp({
        url:'http://localhost:3001/say',
        params: { name:'zzm' , age:19 },
        callback: 'show'
    }).then(data => {//接到响应后,做相关操作
        console.log(data);
    })

//app.js(服务端)
// server.js
let express = require('express')
let app = express()
app.get('/say', function(req, res) {
  let { name, age,callback } = req.query

  console.log(name) // zzm
  console.log(age); //19
  console.log(callback) // show

  res.end(`${callback}('我不爱你')`)
})
app.listen(3001,function(){
    console.log("服务端已连接...");
})

```

**jquery的jsonp形式**

**JSONP都是GET和异步请求的，不存在其他的请求方式和同步请求，且jQuery默认就会给JSONP的请求清除缓存。**

```javascript
$.ajax({
url:"http://crossdomain.com/jsonServerResponse",
dataType:"jsonp",
type:"get",//可以省略
jsonpCallback:"show",//->自定义传递给服务器的函数名，而不是使用jQuery自动生成的，可省略
jsonp:"callback",//->把传递函数名的那个形参callback，可省略
success:function (data){
console.log(data);}
});
```

##### 2.cors

Access-Control-Allow-Origin为*的时候，前端设置withCredentials：true，将不能发送cookie到服务端。

**CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现**。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。

虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为**简单请求**和**复杂请求**。

**简单请求**

**条件1**：使用下列方法之一：

- GET
- HEAD
- POST

**条件2**：Content-Type 的值仅限于下列三者之一：

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded

请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

​	**复杂请求**

不符合以上条件的请求就肯定是复杂请求了。 复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。

在服务端一般使用以下方法解决浏览器跨域

需要要注意的是:**当设置`Access-Control-Allow-Origin`为*时,客户端不允许传递cookie()**

```javascript

	// 设置哪个源可以访问我
    res.setHeader('Access-Control-Allow-Origin', '*')
     // 允许携带哪个头访问我
    res.setHeader('Access-Control-Allow-Headers', 'name')
     // 允许哪个方法访问我
    res.setHeader('Access-Control-Allow-Methods', 'PUT')
    // 允许携带cookie
    res.setHeader('Access-Control-Allow-Credentials', true)
    // 预检的存活时间
    res.setHeader('Access-Control-Max-Age', 6)
    // 允许返回的头
    res.setHeader('Access-Control-Expose-Headers', 'name')
```

实例

```javascript
//ajax.html(客户端)
const ajax = {
put(url,fn){
    const xhr = new XMLHttpRequest()

    // document.cookie = 'name=xiamen' // cookie不能跨域
    // xhr.withCredentials = true // 前端设置是否带cookie

    xhr.open('PUT',url,true)

    xhr.setRequestHeader('name','zzm')

    xhr.onreadystatechange = function(){
        if ( xhr.readyState === 4) {
            fn(xhr.responseText)
        }
    }
    xhr.send()
}

}

ajax.put('http://localhost:3001/cors',function(data){
    console.log("res",data);
})
//app.js(服务端)
let express = require('express')
let app = express()



app.use( function(req,res,next){
    // 设置哪个源可以访问我
    res.setHeader('Access-Control-Allow-Origin', '*')
     // 允许携带哪个头访问我
    res.setHeader('Access-Control-Allow-Headers', 'name')
     // 允许哪个方法访问我
    res.setHeader('Access-Control-Allow-Methods', 'PUT')
    // 允许携带cookie
    res.setHeader('Access-Control-Allow-Credentials', true)
    // 预检的存活时间
    res.setHeader('Access-Control-Max-Age', 6)
    // 允许返回的头
    res.setHeader('Access-Control-Expose-Headers', 'name')

    if (req.method === 'OPTIONS') {
        console.log("执行预请求");
         res.end() // OPTIONS请求不做任何处理
        
    }
    next()

})


app.get('/say', function(req, res) {//jsonp方式请求
  let { name, age,callback } = req.query

  console.log(name) // zzm
  console.log(age); //19
  console.log(callback) // show

  return res.end(`${callback}('我不爱你')`)
})


app.put('/cors',function(req,res){//ajax方式请求
    console.log("请求cors");

    return res.end(`你好呀zzm`)

})

app.listen(3001,function(){
    console.log("服务端已连接...");
})
```

##### 3.postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

> otherWindow.postMessage(message, targetOrigin, [transfer]);

- message: 将要发送到其他 window的数据。
- targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回"我不爱你"。

```javascript
// a.html
  <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"></iframe> //等它加载完触发一个事件
  //内嵌在http://localhost:3000/a.html
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>

// b.html
  window.onmessage = function(e) {
    console.log(e.data) //我爱你
    e.source.postMessage('我不爱你', e.origin)
 }
```

##### 4.node中间件代理(两次跨域)

**实现原理**:浏览器之间存在同源策略,但是服务器之间不需要遵守同源策略,于是我们可以将请求代理服务器，再有代理服务器将请求转发给目标服务器,在拿到响应后再将响应转发给客户端

![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031604697.webp)

##### 5.niginx反向代理

实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

**实现思路**：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

先下载[nginx](https://link.juejin.cn?target=http%3A%2F%2Fnginx.org%2Fen%2Fdownload.html)，然后将nginx目录下的nginx.conf修改如下:

```javascript
// proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
复制代码
```

最后通过命令行`nginx -s reload`启动nginx

```javascript
// index.html
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();

// server.js
var http = require('http');
var server = http.createServer();
var qs = require('querystring');
server.on('request', function(req, res) {
    var params = qs.parse(req.url.substring(2));
    // 向前台写cookie
    res.writeHead(200, {
        'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'   // HttpOnly:脚本无法读取
    });
    res.write(JSON.stringify(params));
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
```

#### 总结

- CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
- JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。
- 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制。
- 日常工作中，用得比较多的跨域方案是cors和nginx反向代理



### 2.XSS

#### 1.**什么是xss**

> XSS，即 Cross Site Script，中译是**跨站脚本攻击**；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

XSS攻击可以分为3类：**反射型**（非持久型）、**存储型**（持久型）、**基于DOM**。

**反射型**

反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

**存储型**

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

**DOM型**

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

#### 2.xss攻击预防

**HttpOnly 防止劫取 Cookie**

HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。

上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

**输入检查**

**不要相信用户的任何输入。** 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。

在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 `<`，`>` 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。

而在一些前端框架中，都会有一份 `decodingMap`， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 `<`，`>`，`script`，防止 XSS 攻击：

```
// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
}
复制代码
```

**输出检查**

用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 [sanitize-html](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpunkave%2Fsanitize-html) 对输出内容进行有规则的过滤之后再输出到页面中。

### 3.CSRF

#### 1.什么是CSRF

> CSRF，即 Cross Site Request Forgery，中9跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。

通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作

在举例子之前，先说说浏览器的 Cookie 策略。

**浏览器的 Cookie 策略**

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 个性化设置（如用户自定义设置、主题等）

而浏览器所持有的 Cookie 分为两种：

- Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。
- Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。

```
res.setHeader('Set-Cookie', ['mycookie=222', 'test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;']);
```

上述代码创建了两个 Cookie：`mycookie` 和 `test`，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 `Expires` 属性值会不一样：

Firefox：

[![firefox cookie](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031827192.webp)](https://link.juejin.cn?target=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png)

Chrome:

[![chrome cookie](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031827485.webp)](https://link.juejin.cn?target=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png)

此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 `donmain` 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。

**通过 Cookie 进行 CSRF 攻击**

假设有一个 bbs 站点：`http://www.c.com`，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：

```
http://www.c.com:8002/content/delete/:id
```

如发起 `http://www.c.com:8002/content/delete/87343` 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：

```
res.setHeader('Set-Cookie', ['user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;']);
```

[![user](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031827196.webp)](https://link.juejin.cn?target=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png)

`user` 对应的值是用户 ID。然后构造一个页面 A：

```
<p>CSRF 攻击者准备的网站：</p>
<img src="http://www.c.com:8002/content/delete/87343">
```

页面 A 使用了一个 `img` 标签，其地址指向了删除用户帖子的链接：

[![A](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031827209.webp)](https://link.juejin.cn?target=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png)

可以看到，当登录用户访问攻击者的网站时，会向 `www.c.com` 发起一个删除用户帖子的请求。此时若用户在切换到 `www.c.com` 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。

由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。

但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。

#### 2.CSRF 攻击的防范

当前，对 CSRF 攻击的防范措施主要有如下几种方式。

**验证码**

验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。

从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。

但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。

**Referer Check**

根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。

比如，如果用户要删除自己的帖子，那么先要登录 `www.c.com`，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 `http://www.c.com`；当请求是从 `www.a.com` 发起时，Referer 的值是 `http://www.a.com` 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 `www.c.com`    开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。

针对上文的例子，可以在服务端增加如下代码：

```
if (req.headers.referer !== 'http://www.c.com:8002/') {
    res.write('csrf 攻击');
    return;
}
```

[![referer check](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204031827188.webp)](https://link.juejin.cn?target=https%3A%2F%2Fuser-images.githubusercontent.com%2F7871813%2F42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png)

Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 "防止图片盗链"。

**添加 token 验证**

CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是    CSRF 攻击而拒绝该请求。

### 4.前后端鉴权认证

#### 1.什么是认证

通俗地讲就是**验证当前用户的身份**，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）

互联网中的认证：

- 用户名密码登录
- 邮箱发送登录链接
- 手机号接收验证码
- 只要你能收到邮箱/验证码，就默认你是账号的主人



#### 2.什么是授权

**用户授予第三方应用访问该用户某些资源的权限**

- 你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）
- 你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）

实现授权的方式有：cookie、session、token、OAuth



#### 3.什么是凭证

**实现认证和授权的前提**是需要一种**媒介（证书）** 来标记访问者的身份

- 在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。
- 在现实生活中，每个人都会有一张专属的[居民身份证](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81%2F2080960)，是用于证明持有人身份的一种法定[证件](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E8%AF%81%E4%BB%B6%2F5804999)。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是**认证的凭证。**
- 在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。

#### 4.什么是cookie

- **HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息**）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
- **cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- **cookie 是不可跨域的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，**一级域名和二级域名之间是允许共享使用的**（**靠的是 domain）**。(需要客户端和服务端都满足对应条件才可以跨域)

**cookie 重要的属性**

| 属性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **name=value** | 键值对，设置 Cookie 的名称及相对应的值，都必须是**字符串类型** - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。 |
| **domain**     | 指定 cookie 所属域名，默认是当前域名                         |
| **path**       | **指定 cookie 在哪个路径（路由）下生效，默认是 '/'**。 如果设置为 `/abc`，则只有 `/abc` 下的路由可以访问到该 cookie，如：`/abc/read`。 |
| **maxAge**     | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - **比 expires 好用**。 |
| **expires**    | 过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| **secure**     | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| **httpOnly**   | **如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全** |

#### 5.什么是session

- **session 是另一种记录服务器和客户端会话状态的机制**
- **session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中**



![session.png](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204041323946.webp)



- session 认证流程：
  - 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
  - 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
  - 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
  - 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。

根据以上流程可知，**SessionID 是连接 Cookie 和 Session 的一道桥梁**，大部分系统也是根据此原理来验证用户登录状态。



#### 6.cookie和session的区别

**安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。

**存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。

**有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。

**存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

#### 7.什么是Token

**Acesss Token**

- **访问资源接口（API）时所需要的资源凭证**
- **简单 token 的组成：** uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
- 特点：
  - **服务端无状态化、可扩展性好**
  - **支持移动端设备**
  - 安全
  - 支持跨程序调用
- **token 的身份验证流程：**



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204041324096.webp)



1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

- **每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里**
- **基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库**
- **token 完全由应用管理，所以它可以避开同源策略**

**Refresh Token**

- 另外一种 token——refresh token
- refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204041324087.webp)



- Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
- Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。

#### 8.Token 和 Session 的区别

- Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**
- Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**
- 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**

#### 9.什么是 JWT

- JSON Web Token（简称 JWT）是目前最流行的**跨域认证**解决方案。
- 是一种**认证授权机制**。
- JWT 是为了在网络应用环境间**传递声明**而执行的一种基于 JSON 的开放标准（[RFC 7519](https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7519)）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。
- 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。

#### 10.JWT 的原理



![img](http://image-yunsheng.test.upcdn.net/typora-cloud-img/raw/master/202204041327289.webp)



- JWT 认证流程：
  - 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT
  - 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）
  - 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样

```
Authorization: Bearer <token>
复制代码
```

- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为
- 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要
- 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制



#### 11.JWT 的使用方式

- 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

**方式一**

- 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。

  ```
  GET /calendar/v1/events
  Host: api.example.com
  Authorization: Bearer <token>
  复制代码
  ```

  - 用户的状态不会存储在服务端的内存中，这是一种 **无状态的认证机制**
  - 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。
  - 由于 JWT 是自包含的，因此减少了需要查询数据库的需要
  - JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。
  - 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而**不需要担心跨域资源共享问题**（CORS）

**方式二**

- 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。

**方式三**

- 通过 URL 传输

```
http://www.example.com/user?token=xxx
```

#### 12.Token 和 JWT 的区别  

**相同：**

- 都是访问资源的令牌
- 都可以记录用户的信息
- 都是使服务端无状态化
- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。


出处。

#### 13.常见的前后端鉴权方式 

1. Session-Cookie
2. Token 验证（包括 JWT，SSO）
3. OAuth2.0（开放授权）

